

# Детальное руководство по команде MOV процессора x86-64

## Содержание
- [Введение](#введение)
- [Как пользоваться этим руководством](#как-пользоваться-этим-руководством)
- [Описание команды MOV](#описание-команды-mov)
- [Варианты команды MOV](#варианты-команды-mov)
- [Детальный разбор машинного кода](#детальный-разбор-машинного-кода)
  - [Детальный разбор опкода 88 (MOV r/m8, r8)](#детальный-разбор-опкода-88-mov-rm8-r8)
  - [MOV регистр, регистр](#mov-регистр-регистр)
- [Примеры использования](#примеры-использования)

## Введение

Это руководство содержит подробное описание команды MOV процессора архитектуры x86-64 с детальным разбором её машинного кода. Для команды приведены:
- Синтаксис на языке ассемблера
- Описание операции
- Формат машинного кода с разбором каждого байта
- Визуальное представление структуры команды
- Примеры использования

## Как пользоваться этим руководством

1. Используйте [Содержание](#содержание) для быстрого перехода к нужному разделу
2. В разделе [Варианты команды MOV](#варианты-команды-mov) вы найдете все возможные варианты использования команды
3. В разделе [Детальный разбор машинного кода](#детальный-разбор-машинного-кода) представлен подробный анализ байтов машинного кода
4. Используйте кнопку **[⬆️ Вернуться к содержанию]** для быстрого возврата к оглавлению

## Описание команды MOV

**[⬆️ Вернуться к содержанию](#содержание)**

Команда MOV копирует данные из источника в приемник. Это одна из самых базовых и часто используемых команд в архитектуре x86-64.

### Синтаксис

```assembly
MOV приемник, источник
```

### Операция

```
приемник ← источник
```

### Флаги

Команда MOV не влияет на флаги.

## Варианты команды MOV

**[⬆️ Вернуться к содержанию](#содержание)**

### Основные варианты

1. **MOV регистр, регистр** - копирование данных из одного регистра в другой
2. **MOV регистр, память** - копирование данных из памяти в регистр
3. **MOV память, регистр** - копирование данных из регистра в память
4. **MOV регистр, непосредственное значение** - загрузка непосредственного значения в регистр
5. **MOV память, непосредственное значение** - загрузка непосредственного значения в память

### Специальные варианты

6. **MOV регистр, сегментный регистр** - копирование из сегментного регистра
7. **MOV сегментный регистр, регистр** - копирование в сегментный регистр
8. **MOV регистр, управляющий регистр** - копирование из управляющего регистра
9. **MOV управляющий регистр, регистр** - копирование в управляющий регистр
10. **MOV регистр, отладочный регистр** - копирование из отладочного регистра
11. **MOV отладочный регистр, регистр** - копирование в отладочный регистр

### Таблица опкодов MOV

#### Основные опкоды MOV

| № | Опкод | Мнемоника | Описание | Пример |
|---|-------|-----------|----------|--------|
| 1 | 88 /r | MOV r/m8, r8 | Копирование 8-битного регистра в регистр/память | MOV AL, BL |
| 2 | 89 /r | MOV r/m16, r16 | Копирование 16-битного регистра в регистр/память | MOV AX, BX |
| 3 | 89 /r | MOV r/m32, r32 | Копирование 32-битного регистра в регистр/память | MOV EAX, EBX |
| 4 | REX.W + 89 /r | MOV r/m64, r64 | Копирование 64-битного регистра в регистр/память | MOV RAX, RBX |
| 5 | 8A /r | MOV r8, r/m8 | Копирование из регистра/памяти в 8-битный регистр | MOV BL, AL |
| 6 | 8B /r | MOV r16, r/m16 | Копирование из регистра/памяти в 16-битный регистр | MOV BX, AX |
| 7 | 8B /r | MOV r32, r/m32 | Копирование из регистра/памяти в 32-битный регистр | MOV EBX, EAX |
| 8 | REX.W + 8B /r | MOV r64, r/m64 | Копирование из регистра/памяти в 64-битный регистр | MOV RBX, RAX |
| 9 | B0+ rb | MOV r8, imm8 | Загрузка 8-битного значения в регистр | MOV AL, 0x12 |
| 10 | B8+ rw | MOV r16, imm16 | Загрузка 16-битного значения в регистр | MOV AX, 0x1234 |
| 11 | B8+ rd | MOV r32, imm32 | Загрузка 32-битного значения в регистр | MOV EAX, 0x12345678 |
| 12 | REX.W + B8+ rd | MOV r64, imm64 | Загрузка 64-битного значения в регистр | MOV RAX, 0x1234567890ABCDEF |
| 13 | C6 /0 | MOV r/m8, imm8 | Загрузка 8-битного значения в регистр/память | MOV BYTE PTR [RBX], 0x12 |
| 14 | C7 /0 | MOV r/m16, imm16 | Загрузка 16-битного значения в регистр/память | MOV WORD PTR [RBX], 0x1234 |
| 15 | C7 /0 | MOV r/m32, imm32 | Загрузка 32-битного значения в регистр/память | MOV DWORD PTR [RBX], 0x12345678 |
| 16 | REX.W + C7 /0 | MOV r/m64, imm32 | Загрузка 32-битного значения с расширением знака в 64-битный регистр/память | MOV QWORD PTR [RBX], 0x12345678 |

#### Опкоды для работы с сегментными и специальными регистрами

| № | Опкод | Мнемоника | Описание | Пример |
|---|-------|-----------|----------|--------|
| 17 | 8C /r | MOV r/m16, Sreg | Копирование из сегментного регистра в регистр/память | MOV AX, CS |
| 18 | 8E /r | MOV Sreg, r/m16 | Копирование из регистра/памяти в сегментный регистр | MOV DS, AX |
| 19 | 0F 20 /r | MOV r64, CR0-CR7 | Копирование из управляющего регистра в регистр | MOV RAX, CR0 |
| 20 | 0F 22 /r | MOV CR0-CR7, r64 | Копирование из регистра в управляющий регистр | MOV CR0, RAX |
| 21 | 0F 21 /r | MOV r64, DR0-DR7 | Копирование из отладочного регистра в регистр | MOV RAX, DR0 |
| 22 | 0F 23 /r | MOV DR0-DR7, r64 | Копирование из регистра в отладочный регистр | MOV DR0, RAX |
| 23 | REX.R + 0F 20 /0 | MOV r64, CR8 | Копирование из расширенного управляющего регистра CR8 в регистр | MOV RAX, CR8 |
| 24 | REX.R + 0F 22 /0 | MOV CR8, r64 | Копирование из регистра в расширенный управляющий регистр CR8 | MOV CR8, RAX |

#### Опкоды для прямой адресации памяти

| № | Опкод | Мнемоника | Описание | Пример |
|---|-------|-----------|----------|--------|
| 25 | A0 | MOV AL, moffs8 | Копирование байта из памяти по смещению в AL | MOV AL, [0x1000] |
| 26 | A1 | MOV AX, moffs16 | Копирование слова из памяти по смещению в AX | MOV AX, [0x1000] |
| 27 | A1 | MOV EAX, moffs32 | Копирование двойного слова из памяти по смещению в EAX | MOV EAX, [0x1000] |
| 28 | REX.W + A1 | MOV RAX, moffs64 | Копирование четверного слова из памяти по смещению в RAX | MOV RAX, [0x1000] |
| 29 | A2 | MOV moffs8, AL | Копирование AL в память по смещению | MOV [0x1000], AL |
| 30 | A3 | MOV moffs16, AX | Копирование AX в память по смещению | MOV [0x1000], AX |
| 31 | A3 | MOV moffs32, EAX | Копирование EAX в память по смещению | MOV [0x1000], EAX |
| 32 | REX.W + A3 | MOV moffs64, RAX | Копирование RAX в память по смещению | MOV [0x1000], RAX |

#### Дополнительные опкоды и специальные инструкции

| № | Опкод | Мнемоника | Описание | Пример |
|---|-------|-----------|----------|--------|
| 33 | 0F 38 F0 /r | MOVBE r16, m16 | Копирование из памяти в регистр с изменением порядка байтов (big-endian) | MOVBE AX, [RBX] |
| 34 | 0F 38 F0 /r | MOVBE r32, m32 | Копирование из памяти в регистр с изменением порядка байтов (big-endian) | MOVBE EAX, [RBX] |
| 35 | REX.W + 0F 38 F0 /r | MOVBE r64, m64 | Копирование из памяти в регистр с изменением порядка байтов (big-endian) | MOVBE RAX, [RBX] |
| 36 | 0F 38 F1 /r | MOVBE m16, r16 | Копирование из регистра в память с изменением порядка байтов (big-endian) | MOVBE [RBX], AX |
| 37 | 0F 38 F1 /r | MOVBE m32, r32 | Копирование из регистра в память с изменением порядка байтов (big-endian) | MOVBE [RBX], EAX |
| 38 | REX.W + 0F 38 F1 /r | MOVBE m64, r64 | Копирование из регистра в память с изменением порядка байтов (big-endian) | MOVBE [RBX], RAX |
| 39 | REX + 8A /r | MOV r8, r/m8 | Копирование из регистра/памяти в 8-битный регистр (с REX префиксом) | MOV R8L, [RAX] |
| 40 | REX + 88 /r | MOV r/m8, r8 | Копирование 8-битного регистра в регистр/память (с REX префиксом) | MOV [RAX], R8L |
| 41 | REX.W + 8C /r | MOV r/m64, Sreg | Копирование из сегментного регистра в 64-битный регистр/память | MOV RAX, CS |
| 42 | REX.W + 8E /r | MOV Sreg, r/m64 | Копирование из 64-битного регистра/памяти в сегментный регистр | MOV CS, RAX |

#### Примечания

1. Обозначение `/r` указывает на использование байта ModR/M для кодирования регистров
2. Обозначение `+rb`, `+rw`, `+rd` указывает на кодирование регистра в опкоде (например, B0 для AL, B1 для CL и т.д.)
3. Префикс REX.W (48h-4Fh) используется для 64-битных операций
4. Префикс REX.R используется для доступа к расширенным регистрам (CR8)
5. Инструкция MOVBE технически является отдельной инструкцией, но включена в таблицу для полноты

> Обратите внимание, что существуют также другие инструкции, начинающиеся с "MOV" (MOVS, MOVD, MOVQ, MOVAPS, MOVDQA и т.д.), но они являются отдельными инструкциями, а не вариантами базовой инструкции MOV.


### Полный список вариантов MOV

В таблицах выше представлены 42 основных варианта команды MOV. Однако, если учитывать все возможные комбинации префиксов, размеров операндов и режимов адресации, то общее количество вариантов команды MOV достигает 63. Некоторые из дополнительных вариантов включают:

1. Варианты с различными префиксами сегментов (CS, DS, ES, FS, GS, SS)
2. Варианты с префиксами REX.B, REX.X, REX.R для доступа к расширенным регистрам
3. Варианты с различными комбинациями SIB-байта (Scale-Index-Base) для сложной адресации
4. Варианты с различными смещениями (8-битное, 32-битное)
5. Специальные варианты для работы с отдельными битами регистров

Детальные примеры использования можно найти в разделе [Детальный разбор машинного кода](#детальный-разбор-машинного-кода).

## Детальный разбор машинного кода

**[⬆️ Вернуться к содержанию](#содержание)**

### Детальный разбор опкода 88 (MOV r/m8, r8)

Опкод 88 используется для копирования 8-битного значения из регистра-источника в регистр или память назначения. Это один из базовых опкодов команды MOV, который работает с 8-битными операндами.

#### Структура машинного кода

```
+--------+--------+--------+--------+
| Префикс | Опкод  | ModR/M |  SIB   | + Смещение (опционально)
|  (опц.) |   88   |        | (опц.) |
+--------+--------+--------+--------+
```

#### Префиксы для опкода 88

Префиксы являются опциональными байтами, которые могут предшествовать опкоду и изменять его поведение. Для опкода 88 могут использоваться следующие префиксы:

1. **Префиксы сегментов** (1 байт):
   - 26h: Префикс сегмента ES
   - 2Eh: Префикс сегмента CS
   - 36h: Префикс сегмента SS
   - 3Eh: Префикс сегмента DS
   - 64h: Префикс сегмента FS
   - 65h: Префикс сегмента GS

   Эти префиксы указывают, какой сегментный регистр использовать для адресации памяти. Например:
   ```assembly
   mov [es:rax], cl  ; Использовать сегмент ES для адресации
   ```
   Машинный код: `26 88 08`

2. **Префиксы размера операнда и адреса** (1 байт):
   - 66h: Префикс размера операнда (не применяется к опкоду 88, так как он всегда работает с 8-битными данными)
   - 67h: Префикс размера адреса (изменяет размер адреса с 64-бит на 32-бит в 64-битном режиме)

   Пример с префиксом размера адреса:
   ```assembly
   mov [eax], cl  ; Использовать 32-битную адресацию вместо 64-битной
   ```
   Машинный код: `67 88 08`

3. **Префиксы блокировки и повторения** (1 байт):
   - F0h: Префикс LOCK (блокировка шины)
   - F2h, F3h: Префиксы повторения (не имеют смысла для MOV)

   Пример с префиксом LOCK:
   ```assembly
   lock mov [rax], cl  ; Блокировка шины при записи
   ```
   Машинный код: `F0 88 08` (хотя это обычно не имеет практического смысла для MOV)

4. **Префиксы REX** (1 байт, только в 64-битном режиме):
   - 40h-4Fh: Префиксы REX для доступа к расширенным регистрам и возможностям

   Структура байта REX:
   ```
   0100WRXB
   ```
   - W: Расширение операнда до 64 бит (не применяется к опкоду 88)
   - R: Расширение поля REG в ModR/M (для доступа к R8-R15)
   - X: Расширение поля индекса в SIB (для доступа к R8-R15)
   - B: Расширение поля R/M в ModR/M или поля базы в SIB (для доступа к R8-R15)

   Примеры:
   ```assembly
   mov [r8], al  ; Использование R8 в качестве базового регистра
   ```
   Машинный код: `41 88 00` (41h - префикс REX.B)

   ```assembly
   mov [rax], r8b  ; Использование R8B в качестве источника
   ```
   Машинный код: `44 88 00` (44h - префикс REX.R)

   ```assembly
   mov r8b, [rax]  ; Использование R8B в качестве назначения
   ```
   Машинный код: `44 8A 00` (44h - префикс REX.R, но опкод меняется на 8A)

Важно отметить, что префиксы должны следовать в определенном порядке:
1. Префиксы группы 1 (LOCK/REP): F0h, F2h, F3h
2. Префиксы группы 2 (сегментные): 26h, 2Eh, 36h, 3Eh, 64h, 65h
3. Префиксы группы 3 (операнд): 66h
4. Префиксы группы 4 (адрес): 67h
5. Префикс REX (только в 64-битном режиме): 40h-4Fh

#### Детальное описание байтов

1. **Префикс (опционально)**:
   - **REX префиксы** (0x40-0x4F) в 64-битном режиме:
     - REX префиксы имеют формат `0100WRXB`, где каждый бит имеет особое значение
     - REX.W (бит 3) = 0: Для опкода 88 всегда 0, так как это 8-битная операция
     - REX.R (бит 2) = 1: Использовать расширенный регистр (R8-R15) для поля Reg (источник)
     - REX.X (бит 1) = 1: Использовать расширенный регистр для поля Index в SIB
     - REX.B (бит 0) = 1: Использовать расширенный регистр для R/M части (назначение)
     - Примеры:
       - 40h (0100 0000): Простой REX префикс без дополнительных флагов
       - 41h (0100 0001): REX.B = 1, использовать R8-R15 для R/M
       - 42h (0100 0010): REX.X = 1, использовать R8-R15 для индекса в SIB
       - 44h (0100 0100): REX.R = 1, использовать R8-R15 для Reg
     
     - **Важные особенности REX префиксов для опкода 88**:
       - Если используется любой REX префикс (даже 40h), то регистры AH, BH, CH, DH становятся недоступны
       - Вместо них используются SPL, BPL, SIL, DIL (младшие байты RSP, RBP, RSI, RDI)
       - Для доступа к младшим байтам R8-R15 (R8L-R15L) требуется соответствующий REX префикс
       - Примеры:
         - `40 88 E0`: MOV AL, SPL (вместо AH)
         - `41 88 C0`: MOV R8L, AL (REX.B = 1)
         - `44 88 C0`: MOV AL, R8L (REX.R = 1)
         - `45 88 C0`: MOV R8L, R9L (REX.B = 1, REX.R = 1)
   
   - **Префиксы сегментов** (опционально):
     - 2Eh: Префикс сегмента CS
     - 36h: Префикс сегмента SS
     - 3Eh: Префикс сегмента DS (по умолчанию, обычно опускается)
     - 26h: Префикс сегмента ES
     - 64h: Префикс сегмента FS
     - 65h: Префикс сегмента GS
     - Используются для указания сегмента при адресации памяти
     - Пример: `65 88 00` - MOV [GS:RAX], AL (запись AL в память по адресу GS:RAX)
   
   - **Префиксы, которые не используются с опкодом 88**:
     - LOCK (F0h): Не может использоваться с MOV, так как это не атомарная операция
     - Префиксы повторения (F2h, F3h): Не имеют смысла для MOV и игнорируются процессором
     - Операндный префикс (66h): Не влияет на опкод 88, так как он всегда работает с 8-битными операндами
   
   - **Важные особенности использования префиксов**:
     - Префикс REX необходим для доступа к регистрам R8L-R15L
     - Префикс REX несовместим с регистрами AH, BH, CH, DH (нельзя использовать вместе)
     - Префиксы сегментов игнорируются в 64-битном режиме для большинства инструкций, кроме FS и GS
     - Префикс LOCK (F0h) запрещен для MOV и вызывает исключение #UD

2. **Опкод**: 88h - фиксированное значение для данной инструкции

3. **Байт ModR/M**:
   ```
     7   6   5   4   3   2   1   0
   +---+---+---+---+---+---+---+---+
   | Mod |    Reg    |     R/M     |
   +---+---+---+---+---+---+---+---+
   ```
   
   - **Mod (биты 7-6)**: Режим адресации
     - 00: Косвенная адресация через регистр или SIB без смещения
     - 01: Косвенная адресация через регистр + 8-битное смещение
     - 10: Косвенная адресация через регистр + 32-битное смещение
     - 11: Прямая адресация регистра (регистр-регистр)
   
   - **Reg (биты 5-3)**: Регистр-источник (r8)
     - 000: AL (или R8L с REX.R)
     - 001: CL (или R9L с REX.R)
     - 010: DL (или R10L с REX.R)
     - 011: BL (или R11L с REX.R)
     - 100: AH/SPL (или R12L с REX.R)
     - 101: CH/BPL (или R13L с REX.R)
     - 110: DH/SIL (или R14L с REX.R)
     - 111: BH/DIL (или R15L с REX.R)
   
   - **R/M (биты 2-0)**: Регистр/Память назначения
     - Если Mod = 11, то это регистр (аналогично кодировке Reg)
     - Иначе это часть адреса памяти:
       - 000: [RAX] или [EAX]
       - 001: [RCX] или [ECX]
       - 010: [RDX] или [EDX]
       - 011: [RBX] или [EBX]
       - 100: Используется SIB байт
       - 101: Если Mod=00: RIP + смещение, иначе [RBP/EBP] + смещение
       - 110: [RSI] или [ESI]
       - 111: [RDI] или [EDI]

4. **Байт SIB (опционально)**: Используется, когда R/M = 100
   ```
     7   6   5   4   3   2   1   0
   +---+---+---+---+---+---+---+---+
   | Scale |   Index   |    Base    |
   +---+---+---+---+---+---+---+---+
   ```
   
   - **Scale (биты 7-6)**: Множитель для индексного регистра (0=1, 1=2, 2=4, 3=8)
   - **Index (биты 5-3)**: Индексный регистр (000=RAX, 001=RCX, и т.д.)
   - **Base (биты 2-0)**: Базовый регистр (000=RAX, 001=RCX, и т.д.)

5. **Смещение (опционально)**: 1, 2 или 4 байта в зависимости от режима адресации

#### Примеры кодирования опкода 88

1. **MOV AL, BL** (копирование из BL в AL):
   ```
   88 D8
   ```
   Разбор:
   - 88: Опкод
   - D8: ModR/M байт
     - Mod = 11 (прямая адресация регистра)
     - Reg = 011 (BL - источник)
     - R/M = 000 (AL - назначение)

2. **MOV [RBX], CL** (копирование из CL в память по адресу в RBX):
   ```
   88 0B
   ```
   Разбор:
   - 88: Опкод
   - 0B: ModR/M байт
     - Mod = 00 (косвенная адресация без смещения)
     - Reg = 001 (CL - источник)
     - R/M = 011 (RBX - адрес памяти)

3. **MOV [RAX+0x10], DL** (копирование из DL в память по адресу RAX+0x10):
   ```
   88 50 10
   ```
   Разбор:
   - 88: Опкод
   - 50: ModR/M байт
     - Mod = 01 (косвенная адресация с 8-битным смещением)
     - Reg = 010 (DL - источник)
     - R/M = 000 (RAX - базовый регистр)
   - 10: Смещение (16 в десятичной системе)

4. **MOV [RSP+RAX*2], BL** (копирование из BL в память по адресу RSP+RAX*2):
   ```
   88 1C 44
   ```
   Разбор:
   - 88: Опкод
   - 1C: ModR/M байт
     - Mod = 00 (косвенная адресация без смещения)
     - Reg = 011 (BL - источник)
     - R/M = 100 (используется SIB байт)
   - 44: SIB байт
     - Scale = 01 (множитель 2)
     - Index = 000 (RAX)
     - Base = 100 (RSP)

5. **MOV [R8], AL** (копирование из AL в память по адресу в R8, с использованием REX префикса):
   ```
   41 88 00
   ```
   Разбор:
   - 41: REX префикс (REX.B = 1, для доступа к R8)
   - 88: Опкод
   - 00: ModR/M байт
     - Mod = 00 (косвенная адресация без смещения)
     - Reg = 000 (AL - источник)
     - R/M = 000 (R8 с учетом REX.B - адрес памяти)

6. **MOV [GS:RAX], BL** (копирование из BL в память по адресу GS:RAX, с использованием префикса сегмента):
   ```
   65 88 18
   ```
   Разбор:
   - 65: Префикс сегмента GS
   - 88: Опкод
   - 18: ModR/M байт
     - Mod = 00 (косвенная адресация без смещения)
     - Reg = 011 (BL - источник)
     - R/M = 000 (RAX - адрес памяти)

7. **MOV [GS:R8], CL** (комбинация префикса сегмента и REX):
   ```
   65 41 88 08
   ```
   Разбор:
   - 65: Префикс сегмента GS
   - 41: REX префикс (REX.B = 1, для доступа к R8)
   - 88: Опкод
   - 08: ModR/M байт
     - Mod = 00 (косвенная адресация без смещения)
     - Reg = 001 (CL - источник)
     - R/M = 000 (R8 с учетом REX.B - адрес памяти)

#### Особенности и ограничения

1. **Использование регистров**:
   - Без префикса REX доступны только регистры AL, BL, CL, DL, AH, BH, CH, DH
   - С префиксом REX.B можно использовать регистры R8L-R15L в качестве назначения
   - С префиксом REX.R можно использовать регистры R8L-R15L в качестве источника
   - С префиксом REX нельзя использовать регистры AH, BH, CH, DH (они кодируются иначе)

2. **Особенности префиксов**:
   - Префикс REX должен непосредственно предшествовать опкоду (нельзя вставлять другие префиксы между REX и опкодом)
   - Если используется и префикс сегмента, и REX, то префикс сегмента должен идти перед REX
   - Порядок префиксов имеет значение: сначала префиксы сегментов, затем REX
   - Пример: `65 41 88 00` - MOV [GS:R8], AL (префикс GS, затем REX.B, затем опкод)

3. **Ограничения в разных режимах**:
   - В 16-битном режиме опкод 88 работает с 8-битными регистрами и 16-битной адресацией
   - В 32-битном режиме опкод 88 работает с 8-битными регистрами и 32-битной адресацией
   - В 64-битном режиме опкод 88 работает с 8-битными регистрами и 64-битной адресацией
   - Префиксы REX доступны только в 64-битном режиме

#### Визуальное представление

Для инструкции `MOV AL, BL` (88 D8):

```
Опкод  ModR/M
  |      |
  v      v
 88     D8
10001000 11011000
        ││└┴┴┘ AL (000) - регистр назначения
        │└─── Режим 11 (прямая адресация регистров)
        └──── BL (011) - регистр источник
```

### MOV регистр, регистр

#### Пример: MOV RAX, RBX (копирование 64-битного регистра в 64-битный регистр)

##### Ассемблерный код:
```assembly
MOV RAX, RBX
```

##### Машинный код (в шестнадцатеричной системе):
```
48 89 D8
```

##### Разбор машинного кода:
```
48 - REX.W префикс (указывает на 64-битную операцию)
89 - опкод (операция MOV регистр в регистр)
D8 - байт ModR/M:
     - Мод = 11 (режим регистр-регистр)
     - Рег = 011 (регистр RBX, источник)
     - R/M = 000 (регистр RAX, приемник)
```

##### Визуальное представление:
```
┌─────────┬─────────┬─────────┐
│   48    │   89    │   D8    │
├─────────┼─────────┼─────────┤
│ REX.W   │ Опкод   │ ModR/M  │
│ префикс │         │         │
└─────────┴─────────┴─────────┘
    │         │         │
    ▼         ▼         ▼
┌─────────┐ ┌─────────┐ ┌─────────┐
│0100 1000│ │1000 1001│ │1101 1000│
└─────────┘ └─────────┘ └─────────┘
                          │   │  │
                          ▼   ▼  ▼
                        ┌──┐┌───┐┌──┐
                        │11││011││000│
                        └──┘└───┘└──┘
                          │   │    │
                          ▼   ▼    ▼
                        режим регистр регистр
                        рег-рег  RBX     RAX
                                (источник)(приемник)
```

### MOV регистр, непосредственное значение

#### Пример: MOV RAX, 0x1234567890ABCDEF (загрузка 64-битного значения в регистр)

##### Ассемблерный код:
```assembly
MOV RAX, 0x1234567890ABCDEF
```

##### Машинный код (в шестнадцатеричной системе):
```
48 B8 EF CD AB 90 78 56 34 12
```

##### Разбор машинного кода:
```
48 - REX.W префикс (указывает на 64-битную операцию)
B8 - опкод (операция MOV непосредственное значение в регистр RAX)
EF CD AB 90 78 56 34 12 - непосредственное значение 0x1234567890ABCDEF в порядке little-endian
```

##### Визуальное представление:
```
┌─────────┬─────────┬─────────────────────────────────────────────────┐
│   48    │   B8    │  EF CD AB 90 78 56 34 12                        │
├─────────┼─────────┼─────────────────────────────────────────────────┤
│ REX.W   │ Опкод+  │  Непосредственное значение (8 байт)             │
│ префикс │ регистр │                                                 │
└─────────┴─────────┴─────────────────────────────────────────────────┘
    │         │         │
    ▼         ▼         ▼
┌─────────┐ ┌─────────┐ ┌─────────────────────────────────────────────┐
│0100 1000│ │1011 1000│ │ EF CD AB 90 78 56 34 12                     │
└─────────┘ └─────────┘ └─────────────────────────────────────────────┘
                │   │
                ▼   ▼
              ┌────┐┌───┐
              │1011││000│
              └────┘└───┘
                │    │
                ▼    ▼
              базовый номер
              опкод  регистра
                     RAX = 0
```

### MOV регистр, память

#### Пример: MOV RAX, [RBX] (загрузка из памяти по адресу в RBX)

##### Ассемблерный код:
```assembly
MOV RAX, [RBX]
```

##### Машинный код (в шестнадцатеричной системе):
```
48 8B 03
```

##### Разбор машинного кода:
```
48 - REX.W префикс (указывает на 64-битную операцию)
8B - опкод (операция MOV из памяти в регистр)
03 - байт ModR/M:
     - Мод = 00 (режим косвенной адресации без смещения)
     - Рег = 000 (регистр RAX, приемник)
     - R/M = 011 (регистр RBX, содержит адрес)
```

##### Визуальное представление:
```
┌─────────┬─────────┬─────────┐
│   48    │   8B    │   03    │
├─────────┼─────────┼─────────┤
│ REX.W   │ Опкод   │ ModR/M  │
│ префикс │         │         │
└─────────┴─────────┴─────────┘
    │         │         │
    ▼         ▼         ▼
┌─────────┐ ┌─────────┐ ┌─────────┐
│0100 1000│ │1000 1011│ │0000 0011│
└─────────┘ └─────────┘ └─────────┘
                          │   │  │
                          ▼   ▼  ▼
                        ┌──┐┌───┐┌──┐
                        │00││000││011│
                        └──┘└───┘└──┘
                          │   │    │
                          ▼   ▼    ▼
                        режим регистр регистр
                        памяти   RAX     RBX
                               (приемник)(адрес)
```

### MOV память, регистр

#### Пример: MOV [RBX], RAX (сохранение регистра в память по адресу в RBX)

##### Ассемблерный код:
```assembly
MOV [RBX], RAX
```

##### Машинный код (в шестнадцатеричной системе):
```
48 89 03
```

##### Разбор машинного кода:
```
48 - REX.W префикс (указывает на 64-битную операцию)
89 - опкод (операция MOV из регистра в память)
03 - байт ModR/M:
     - Мод = 00 (режим косвенной адресации без смещения)
     - Рег = 000 (регистр RAX, источник)
     - R/M = 011 (регистр RBX, содержит адрес)
```

##### Визуальное представление:
```
┌─────────┬─────────┬─────────┐
│   48    │   89    │   03    │
├─────────┼─────────┼─────────┤
│ REX.W   │ Опкод   │ ModR/M  │
│ префикс │         │         │
└─────────┴─────────┴─────────┘
    │         │         │
    ▼         ▼         ▼
┌─────────┐ ┌─────────┐ ┌─────────┐
│0100 1000│ │1000 1001│ │0000 0011│
└─────────┘ └─────────┘ └─────────┘
                          │   │  │
                          ▼   ▼  ▼
                        ┌──┐┌───┐┌──┐
                        │00││000││011│
                        └──┘└───┘└──┘
                          │   │    │
                          ▼   ▼    ▼
                        режим регистр регистр
                        памяти   RAX     RBX
                               (источник)(адрес)
```

### MOV память, непосредственное значение

#### Пример: MOV QWORD PTR [RBX], 0x1234567890ABCDEF (запись 64-битного значения в память)

##### Ассемблерный код:
```assembly
MOV QWORD PTR [RBX], 0x1234567890ABCDEF
```

##### Машинный код (в шестнадцатеричной системе):
```
48 C7 03 EF CD AB 90 48 C7 43 04 78 56 34 12
```

##### Разбор машинного кода:
```
Так как непосредственное 64-битное значение не может быть закодировано в одной инструкции,
компилятор разбивает его на две 32-битные инструкции:

Первая инструкция (младшие 32 бита):
48 - REX.W префикс (указывает на 64-битную операцию)
C7 - опкод (операция MOV непосредственное значение в память)
03 - байт ModR/M:
     - Мод = 00 (режим косвенной адресации без смещения)
     - Рег = 000 (расширение опкода)
     - R/M = 011 (регистр RBX, содержит адрес)
EF CD AB 90 - непосредственное значение 0x90ABCDEF в порядке little-endian

Вторая инструкция (старшие 32 бита):
48 - REX.W префикс (указывает на 64-битную операцию)
C7 - опкод (операция MOV непосредственное значение в память)
43 - байт ModR/M:
     - Мод = 01 (режим косвенной адресации с 8-битным смещением)
     - Рег = 000 (расширение опкода)
     - R/M = 011 (регистр RBX, содержит адрес)
04 - смещение (4 байта от начального адреса)
78 56 34 12 - непосредственное значение 0x12345678 в порядке little-endian
```

##### Визуальное представление (первая инструкция):
```
┌─────────┬─────────┬─────────┬─────────────────────────┐
│   48    │   C7    │   03    │  EF CD AB 90            │
├─────────┼─────────┼─────────┼─────────────────────────┤
│ REX.W   │ Опкод   │ ModR/M  │  Непосредственное       │
│ префикс │         │         │  значение (4 байта)     │
└─────────┴─────────┴─────────┴─────────────────────────┘
```

##### Визуальное представление (вторая инструкция):
```
┌─────────┬─────────┬─────────┬─────────┬─────────────────────────┐
│   48    │   C7    │   43    │   04    │  78 56 34 12            │
├─────────┼─────────┼─────────┼─────────┼─────────────────────────┤
│ REX.W   │ Опкод   │ ModR/M  │ Смещение│  Непосредственное       │
│ префикс │         │         │         │  значение (4 байта)     │
└─────────┴─────────┴─────────┴─────────┴─────────────────────────┘
```

## Примеры использования

**[⬆️ Вернуться к содержанию](#содержание)**

### Пример 1: Копирование значения между регистрами

```assembly
MOV RAX, RBX    ; Копирует 64-битное значение из RBX в RAX
MOV ECX, EDX    ; Копирует 32-битное значение из EDX в ECX
MOV AX, BX      ; Копирует 16-битное значение из BX в AX
MOV AL, BL      ; Копирует 8-битное значение из BL в AL
```

### Пример 2: Загрузка непосредственного значения в регистр

```assembly
MOV RAX, 0x1234567890ABCDEF    ; Загружает 64-битное значение в RAX
MOV ECX, 0x12345678            ; Загружает 32-битное значение в ECX
MOV AX, 0x1234                 ; Загружает 16-битное значение в AX
MOV AL, 0x12                   ; Загружает 8-битное значение в AL
```

### Пример 3: Работа с памятью

```assembly
MOV RAX, [RBX]                 ; Загружает 64-битное значение из памяти по адресу в RBX
MOV [RCX], RAX                 ; Сохраняет 64-битное значение RAX в память по адресу в RCX
MOV RAX, [RBX+RCX*4+0x10]      ; Загружает значение из памяти с использованием SIB-байта
MOV QWORD PTR [RBX], 0x1234    ; Сохраняет непосредственное значение в память
```

### Пример 4: Работа с сегментными регистрами

```assembly
MOV AX, CS                     ; Копирует значение из сегментного регистра CS в AX
MOV DS, AX                     ; Копирует значение из AX в сегментный регистр DS
```

### Пример 5: Работа с управляющими и отладочными регистрами

```assembly
MOV RAX, CR0                   ; Копирует значение из управляющего регистра CR0 в RAX
MOV CR3, RAX                   ; Копирует значение из RAX в управляющий регистр CR3
MOV RBX, DR0                   ; Копирует значение из отладочного регистра DR0 в RBX
MOV DR7, RBX                   ; Копирует значение из RBX в отладочный регистр DR7
```

**[⬆️ Вернуться к содержанию](#содержание)**