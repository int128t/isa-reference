# Детальный разбор опкодов ADD (00h-05h)

## Обзор группы ADD

Группа ADD демонстрирует классический паттерн кодирования x86, который повторяется для многих арифметических операций:

| Опкод | Инструкция | Описание |
|-------|------------|----------|
| **00h** | ADD r/m8, r8 | Сложить 8-битный регистр с r/m8 |
| **01h** | ADD r/m16/32/64, r16/32/64 | Сложить регистр с r/m (16/32/64 бита) |
| **02h** | ADD r8, r/m8 | Сложить r/m8 с 8-битным регистром |
| **03h** | ADD r16/32/64, r/m16/32/64 | Сложить r/m с регистром (16/32/64 бита) |
| **04h** | ADD AL, imm8 | Сложить непосредственное значение с AL |
| **05h** | ADD EAX/RAX, imm16/32 | Сложить непосредственное значение с EAX/RAX |

---

## Опкод 00h: ADD r/m8, r8

### Формат инструкции
```
00h [ModR/M] [SIB] [Displacement]
```

### Семантика
- **Назначение**: r/m8 = r/m8 + r8
- **Размер операндов**: 8 бит
- **Направление**: источник (r8) → назначение (r/m8)
- **Флаги**: OF, SF, ZF, AF, PF, CF

### Кодирование ModR/M
```
ModR/M = MMRRR RRR
MM (Mod): режим адресации назначения
RRR (Reg): регистр-источник (r8)
RRR (R/M): регистр/память назначения (r/m8)
```

### Примеры с разбором

#### Пример 1: ADD AL, BL
```assembly
add al, bl          ; 00 D8
```
**Разбор:**
- 00h - опкод ADD r/m8, r8
- D8h = 11 011 000₂
  - Mod = 11 (регистр-регистр)
  - Reg = 011 (BL - источник)
  - R/M = 000 (AL - назначение)

#### Пример 2: ADD [RAX], CL
```assembly
add [rax], cl       ; 00 08
```
**Разбор:**
- 00h - опкод
- 08h = 00 001 000₂
  - Mod = 00 (косвенная адресация без смещения)
  - Reg = 001 (CL - источник)
  - R/M = 000 ([RAX] - назначение)

#### Пример 3: ADD [RBX+8], DL
```assembly
add [rbx+8], dl     ; 00 53 08
```
**Разбор:**
- 00h - опкод
- 53h = 01 010 011₂
  - Mod = 01 (косвенная с 8-битным смещением)
  - Reg = 010 (DL - источник)
  - R/M = 011 (RBX - база)
- 08h - смещение (+8)

#### Пример 4: ADD [RAX+RCX*2+16], R8B
```assembly
add [rax+rcx*2+16], r8b    ; 44 00 44 48 10
```
**Разбор:**
- 44h - REX префикс (REX.R = 1 для R8B)
- 00h - опкод
- 44h = 01 000 100₂ (ModR/M)
  - Mod = 01 (косвенная с 8-битным смещением)
  - Reg = 000 (R8B с учетом REX.R=1)
  - R/M = 100 (требуется SIB)
- 48h = 01 001 000₂ (SIB)
  - Scale = 01 (×2)
  - Index = 001 (RCX)
  - Base = 000 (RAX)
- 10h - смещение (+16)

---

## Опкод 01h: ADD r/m16/32/64, r16/32/64

### Формат инструкции
```
[66h] [REX] 01h [ModR/M] [SIB] [Displacement]
```

### Размеры операндов
- **По умолчанию в 64-битном режиме**: 32 бита
- **С префиксом 66h**: 16 бит
- **С REX.W=1**: 64 бита

### Примеры с разбором

#### Пример 1: ADD EAX, EBX (32-битные)
```assembly
add eax, ebx        ; 01 D8
```
**Разбор:**
- 01h - опкод
- D8h = 11 011 000₂
  - Mod = 11 (регистр-регистр)
  - Reg = 011 (EBX - источник)
  - R/M = 000 (EAX - назначение)

#### Пример 2: ADD AX, BX (16-битные)
```assembly
add ax, bx          ; 66 01 D8
```
**Разбор:**
- 66h - префикс размера операнда (32→16 бит)
- 01h - опкод
- D8h - тот же ModR/M, но теперь для 16-битных регистров

#### Пример 3: ADD RAX, RBX (64-битные)
```assembly
add rax, rbx        ; 48 01 D8
```
**Разбор:**
- 48h - REX.W=1 (64-битные операции)
- 01h - опкод
- D8h - ModR/M

#### Пример 4: ADD [RSI+RDI*4], R15
```assembly
add [rsi+rdi*4], r15    ; 4C 01 3C BE
```
**Разбор:**
- 4Ch - REX (REX.R=1 для R15)
- 01h - опкод
- 3Ch = 00 111 100₂ (ModR/M)
  - Mod = 00 (косвенная без смещения)
  - Reg = 111 (R15 с REX.R=1)
  - R/M = 100 (SIB)
- BEh = 10 111 110₂ (SIB)
  - Scale = 10 (×4)
  - Index = 111 (RDI)
  - Base = 110 (RSI)

---

## Опкод 02h: ADD r8, r/m8

### Особенность
Это **обратная** версия 00h - теперь источником является r/m8, а назначением r8.

### Формат инструкции
```
[REX] 02h [ModR/M] [SIB] [Displacement]
```

### Примеры с разбором

#### Пример 1: ADD BL, AL
```assembly
add bl, al          ; 02 D8
```
**Разбор:**
- 02h - опкод ADD r8, r/m8
- D8h = 11 011 000₂
  - Mod = 11 (регистр-регистр)
  - Reg = 011 (BL - назначение)
  - R/M = 000 (AL - источник)

#### Пример 2: ADD CL, [RAX]
```assembly
add cl, [rax]       ; 02 08
```
**Разбор:**
- 02h - опкод
- 08h = 00 001 000₂
  - Mod = 00 (косвенная без смещения)
  - Reg = 001 (CL - назначение)
  - R/M = 000 ([RAX] - источник)

---

## Опкод 03h: ADD r16/32/64, r/m16/32/64

### Обратная версия 01h
Источник и назначение поменялись местами.

### Примеры с разбором

#### Пример 1: ADD EBX, EAX
```assembly
add ebx, eax        ; 03 D8
```
**Разбор:**
- 03h - опкод
- D8h = 11 011 000₂
  - Mod = 11
  - Reg = 011 (EBX - назначение)
  - R/M = 000 (EAX - источник)

#### Пример 2: ADD RAX, [RBX+RCX*8+32]
```assembly
add rax, [rbx+rcx*8+32]    ; 48 03 44 CB 20
```
**Разбор:**
- 48h - REX.W=1
- 03h - опкод
- 44h = 01 000 100₂ (ModR/M)
  - Mod = 01 (8-битное смещение)
  - Reg = 000 (RAX - назначение)
  - R/M = 100 (SIB)
- CBh = 11 001 011₂ (SIB)
  - Scale = 11 (×8)
  - Index = 001 (RCX)
  - Base = 011 (RBX)
- 20h - смещение (+32)

---

## Опкод 04h: ADD AL, imm8

### Специальная форма для аккумулятора
Оптимизированная инструкция для сложения с регистром AL.

### Формат инструкции
```
04h [imm8]
```

### Примеры с разбором

#### Пример 1: ADD AL, 42h
```assembly
add al, 42h         ; 04 42
```
**Разбор:**
- 04h - опкод ADD AL, imm8
- 42h - непосредственное значение

#### Пример 2: ADD AL, 255
```assembly
add al, 255         ; 04 FF
```
**Разбор:**
- 04h - опкод
- FFh - значение 255

---

## Опкод 05h: ADD EAX/RAX, imm16/32

### Специальная форма для расширенного аккумулятора

### Размеры операндов
- **По умолчанию**: ADD EAX, imm32
- **С префиксом 66h**: ADD AX, imm16  
- **С REX.W=1**: ADD RAX, imm32 (знаковое расширение!)

### Формат инструкции
```
[66h] [REX] 05h [imm16/32]
```

### Примеры с разбором

#### Пример 1: ADD EAX, 12345678h
```assembly
add eax, 12345678h  ; 05 78 56 34 12
```
**Разбор:**
- 05h - опкод ADD EAX, imm32
- 78 56 34 12 - значение 12345678h в little-endian

#### Пример 2: ADD AX, 1234h
```assembly
add ax, 1234h       ; 66 05 34 12
```
**Разбор:**
- 66h - префикс размера (32→16 бит)
- 05h - опкод
- 34 12 - значение 1234h в little-endian

#### Пример 3: ADD RAX, 12345678h
```assembly
add rax, 12345678h  ; 48 05 78 56 34 12
```
**Разбор:**
- 48h - REX.W=1 (64-битная операция)
- 05h - опкод
- 78 56 34 12 - 32-битное значение с знаковым расширением до 64 бит

**Важно**: В 64-битном режиме нет ADD RAX, imm64! Максимум imm32 с знаковым расширением.

---

## Паттерны кодирования

### Логика направления (бит d)
```
Опкод = DDDDDD0d
d=0: r/m ← r (00h, 01h)  
d=1: r ← r/m (02h, 03h)
```

### Логика размера (бит w)
```
Опкод = DDDDDDw0
w=0: 8-битные операции (00h, 02h)
w=1: 16/32/64-битные операции (01h, 03h)
```

### Специальные формы для аккумулятора
- 04h, 05h - оптимизированные версии для AL/AX/EAX/RAX
- Короче обычных форм с ModR/M

---

## Влияние на флаги

Все инструкции ADD влияют на флаги одинаково:

| Флаг | Описание |
|------|----------|
| **OF** | Переполнение при знаковом сложении |
| **SF** | Знак результата (копия старшего бита) |
| **ZF** | Результат равен нулю |
| **AF** | Вспомогательный перенос (из бита 3) |
| **PF** | Четность младшего байта |
| **CF** | Перенос из старшего бита |

### Пример анализа флагов
```assembly
mov al, 0FFh
add al, 1           ; 04 01
; Результат: AL = 00h
; Флаги: ZF=1, CF=1, PF=1, SF=0, OF=0
```

---

## Таблица всех вариантов кодирования

| Размер | Источник | Назначение | Опкод | Пример |
|--------|----------|------------|-------|---------|
| 8 бит | r8 | r/m8 | 00h | `add [rax], bl` |
| 16/32/64 бит | r16/32/64 | r/m16/32/64 | 01h | `add [rax], ebx` |
| 8 бит | r/m8 | r8 | 02h | `add bl, [rax]` |
| 16/32/64 бит | r/m16/32/64 | r16/32/64 | 03h | `add ebx, [rax]` |
| 8 бит | imm8 | AL | 04h | `add al, 42h` |
| 16/32/64 бит | imm16/32 | AX/EAX/RAX | 05h | `add eax, 12345678h` |

---

## Практические рекомендации

### Выбор формы инструкции
1. **Используйте 04h/05h** для операций с аккумулятором - они короче
2. **00h/02h** функционально эквивалентны, выбирайте по читаемости
3. **01h/03h** также эквивалентны

### Оптимизация размера кода
```assembly
; Длинная форма (3 байта)
add eax, ebx        ; 01 D8 или 03 C3

; Для констант с аккумулятором - короче
add eax, 100        ; 05 64 00 00 00 (5 байт)
; вместо
add eax, 100        ; 81 C0 64 00 00 00 (6 байт)
```

### Типичные ошибки
1. **Путать направление** в 00h vs 02h
2. **Забывать REX** для расширенных регистров
3. **Неправильный порядок байт** в imm16/32 (little-endian!)

---

## Заключение

Группа ADD демонстрирует фундаментальные принципы x86-64:
- **Ортогональность**: каждая комбинация размер×направление имеет свой опкод
- **Оптимизация**: специальные короткие формы для аккумулятора
- **Совместимость**: одинаковая логика для всех арифметических операций
- **Расширяемость**: поддержка 8/16/32/64-битных операций