# Инструкции работы со строками x86-64

Инструкции для работы со строками в архитектуре x86-64 предназначены для эффективной обработки последовательностей данных в памяти. Эти инструкции могут работать с отдельными элементами или автоматически обрабатывать целые блоки данных при использовании с префиксами повторения.

## Основные строковые инструкции

### MOVS - Перемещение строки

#### Синтаксис
```
MOVSB                ; Перемещение байта
MOVSW                ; Перемещение слова (2 байта)
MOVSD                ; Перемещение двойного слова (4 байта)
MOVSQ                ; Перемещение четверного слова (8 байт)
```

#### Описание
Копирует элемент данных из памяти по адресу [RSI] в память по адресу [RDI], затем увеличивает или уменьшает RSI и RDI в зависимости от флага DF.

- Если DF=0, регистры увеличиваются (копирование вперед)
- Если DF=1, регистры уменьшаются (копирование назад)

Размер инкремента/декремента зависит от размера операнда:
- MOVSB: 1 байт
- MOVSW: 2 байта
- MOVSD: 4 байта
- MOVSQ: 8 байт

#### Примеры
```assembly
CLD                  ; Сброс флага направления (копирование вперед)
MOV RSI, source      ; Адрес источника
MOV RDI, destination ; Адрес назначения
MOVSQ                ; Копирует 8 байт из [RSI] в [RDI], увеличивает RSI и RDI на 8

STD                  ; Установка флага направления (копирование назад)
LEA RSI, [source+7]  ; Адрес последнего байта источника
LEA RDI, [dest+7]    ; Адрес последнего байта назначения
MOVSB                ; Копирует 1 байт из [RSI] в [RDI], уменьшает RSI и RDI на 1
```

#### Флаги
Не влияет на флаги.

#### Применение
- Копирование блоков памяти
- Перемещение данных
- Реализация функций типа memcpy

### CMPS - Сравнение строк

#### Синтаксис
```
CMPSB                ; Сравнение байтов
CMPSW                ; Сравнение слов (2 байта)
CMPSD                ; Сравнение двойных слов (4 байта)
CMPSQ                ; Сравнение четверных слов (8 байт)
```

#### Описание
Сравнивает элемент данных по адресу [RSI] с элементом по адресу [RDI], устанавливает флаги как при выполнении CMP [RSI], [RDI], затем увеличивает или уменьшает RSI и RDI в зависимости от флага DF.

#### Примеры
```assembly
CLD                  ; Сброс флага направления
MOV RSI, string1     ; Адрес первой строки
MOV RDI, string2     ; Адрес второй строки
CMPSB                ; Сравнивает байты, устанавливает флаги
JE equal             ; Переход, если байты равны
```

#### Флаги
Влияет на флаги так же, как CMP:
- `CF` - устанавливается, если [RSI] < [RDI] (беззнаковое)
- `ZF` - устанавливается, если [RSI] = [RDI]
- `SF` - устанавливается, если результат отрицательный (знаковое сравнение)
- `OF`, `PF`, `AF` - устанавливаются соответственно

#### Применение
- Сравнение строк
- Поиск различий в блоках данных
- Реализация функций типа strcmp

### SCAS - Сканирование строки

#### Синтаксис
```
SCASB                ; Сканирование байтов
SCASW                ; Сканирование слов (2 байта)
SCASD                ; Сканирование двойных слов (4 байта)
SCASQ                ; Сканирование четверных слов (8 байт)
```

#### Описание
Сравнивает аккумулятор (AL/AX/EAX/RAX) с элементом по адресу [RDI], устанавливает флаги как при выполнении CMP AL/AX/EAX/RAX, [RDI], затем увеличивает или уменьшает RDI в зависимости от флага DF.

#### Примеры
```assembly
CLD                  ; Сброс флага направления
MOV RDI, string      ; Адрес строки
MOV AL, 0            ; Ищем нулевой байт (конец строки)
SCASB                ; Сравнивает AL с [RDI], устанавливает флаги
JNE not_found        ; Переход, если не найдено
```

#### Флаги
Влияет на флаги так же, как CMP.

#### Применение
- Поиск символа в строке
- Определение длины строки (поиск нулевого байта)
- Реализация функций типа strchr, strlen

### STOS - Заполнение строки

#### Синтаксис
```
STOSB                ; Заполнение байтами
STOSW                ; Заполнение словами (2 байта)
STOSD                ; Заполнение двойными словами (4 байта)
STOSQ                ; Заполнение четверными словами (8 байт)
```

#### Описание
Записывает значение из аккумулятора (AL/AX/EAX/RAX) в память по адресу [RDI], затем увеличивает или уменьшает RDI в зависимости от флага DF.

#### Примеры
```assembly
CLD                  ; Сброс флага направления
MOV RDI, buffer      ; Адрес буфера
MOV RAX, 0           ; Значение для заполнения
STOSQ                ; Записывает RAX в [RDI], увеличивает RDI на 8
```

#### Флаги
Не влияет на флаги.

#### Применение
- Инициализация буферов
- Заполнение памяти константным значением
- Реализация функций типа memset

### LODS - Загрузка строки

#### Синтаксис
```
LODSB                ; Загрузка байта
LODSW                ; Загрузка слова (2 байта)
LODSD                ; Загрузка двойного слова (4 байта)
LODSQ                ; Загрузка четверного слова (8 байт)
```

#### Описание
Загружает элемент данных из памяти по адресу [RSI] в аккумулятор (AL/AX/EAX/RAX), затем увеличивает или уменьшает RSI в зависимости от флага DF.

#### Примеры
```assembly
CLD                  ; Сброс флага направления
MOV RSI, data        ; Адрес данных
LODSQ                ; Загружает 8 байт из [RSI] в RAX, увеличивает RSI на 8
```

#### Флаги
Не влияет на флаги.

#### Применение
- Чтение данных из памяти
- Обработка элементов массива
- Часть более сложных алгоритмов обработки строк

## Префиксы повторения

### REP/REPE/REPZ/REPNE/REPNZ - Префиксы повторения

#### Синтаксис
```
REP instruction      ; Повторение до RCX=0
REPE/REPZ instruction ; Повторение до RCX=0 или ZF=0
REPNE/REPNZ instruction ; Повторение до RCX=0 или ZF=1
```

#### Описание
Префиксы повторения заставляют строковую инструкцию выполняться в цикле, уменьшая RCX на 1 после каждой итерации, пока не будет достигнуто условие остановки.

- `REP` - повторяет инструкцию, пока RCX не станет равным 0
- `REPE`/`REPZ` - повторяет инструкцию, пока RCX не станет равным 0 или ZF не станет равным 0
- `REPNE`/`REPNZ` - повторяет инструкцию, пока RCX не станет равным 0 или ZF не станет равным 1

#### Совместимость с инструкциями
- `REP` обычно используется с MOVS и STOS
- `REPE`/`REPZ` и `REPNE`/`REPNZ` обычно используются с CMPS и SCAS

#### Примеры
```assembly
; Копирование 100 байт
CLD                  ; Сброс флага направления
MOV RCX, 100         ; Счетчик
MOV RSI, source      ; Адрес источника
MOV RDI, destination ; Адрес назначения
REP MOVSB            ; Копирует 100 байт из [RSI] в [RDI]

; Поиск символа в строке
CLD                  ; Сброс флага направления
MOV RCX, 100         ; Максимальная длина строки
MOV RDI, string      ; Адрес строки
MOV AL, 'A'          ; Искомый символ
REPNE SCASB          ; Ищет 'A' в строке
JE found             ; Переход, если найдено

; Сравнение строк
CLD                  ; Сброс флага направления
MOV RCX, 100         ; Максимальная длина строки
MOV RSI, string1     ; Адрес первой строки
MOV RDI, string2     ; Адрес второй строки
REPE CMPSB           ; Сравнивает строки, пока байты равны
JE equal             ; Переход, если строки равны
```

#### Флаги
Зависит от используемой инструкции.

#### Применение
- Обработка блоков данных
- Эффективная реализация стандартных строковых функций
- Оптимизация циклов обработки массивов

## Управление направлением

### CLD/STD - Управление флагом направления

#### Синтаксис
```
CLD                  ; Clear Direction Flag
STD                  ; Set Direction Flag
```

#### Описание
- `CLD` - сбрасывает флаг направления (DF=0), что заставляет строковые инструкции увеличивать индексные регистры (обработка вперед)
- `STD` - устанавливает флаг направления (DF=1), что заставляет строковые инструкции уменьшать индексные регистры (обработка назад)

#### Примеры
```assembly
CLD                  ; Обработка вперед
REP MOVSB            ; Копирование вперед

STD                  ; Обработка назад
REP MOVSB            ; Копирование назад
```

#### Флаги
Влияют только на флаг DF.

#### Применение
- Управление направлением обработки строк
- Копирование перекрывающихся блоков памяти
- Обработка строк с конца

## Примеры использования строковых инструкций

### Копирование блока памяти (аналог memcpy)

```assembly
; void *memcpy(void *dest, const void *src, size_t n);
; RDI = dest, RSI = src, RDX = n
memcpy:
    MOV RCX, RDX        ; Копируем размер в RCX для REP
    
    ; Проверяем, достаточно ли большой блок для оптимизации
    CMP RCX, 8
    JB .byte_copy       ; Если меньше 8 байт, копируем побайтно
    
    ; Выравниваем назначение по 8 байт
    MOV RAX, RDI
    AND RAX, 7          ; RAX = RDI % 8 (остаток от деления на 8)
    JZ .aligned         ; Если уже выровнено, пропускаем
    
    MOV R8, 8
    SUB R8, RAX         ; R8 = количество байт до выравнивания
    SUB RCX, R8         ; Уменьшаем общий счетчик
    
    ; Копируем байты до выравнивания
    CLD
    REP MOVSB
    
.aligned:
    ; Копируем по 8 байт
    MOV RAX, RCX
    SHR RAX, 3          ; RAX = RCX / 8
    MOV RCX, RAX
    REP MOVSQ
    
    ; Копируем оставшиеся байты
    MOV RCX, RDX
    AND RCX, 7          ; RCX = RDX % 8
    
.byte_copy:
    REP MOVSB
    
    MOV RAX, RDI        ; Возвращаем указатель на назначение
    RET
```

### Поиск символа в строке (аналог strchr)

```assembly
; char *strchr(const char *s, int c);
; RDI = s, RSI = c
strchr:
    MOV RAX, RSI        ; Сохраняем искомый символ в RAX
    MOV AL, SIL         ; Берем только младший байт
    
    MOV RCX, -1         ; Максимально возможная длина
    CLD                 ; Направление вперед
    
    REPNE SCASB         ; Ищем символ
    JNE .not_found      ; Если не найден, возвращаем NULL
    
    LEA RAX, [RDI-1]    ; Возвращаем указатель на найденный символ
    RET
    
.not_found:
    XOR RAX, RAX        ; Возвращаем NULL
    RET
```

### Сравнение строк (аналог strcmp)

```assembly
; int strcmp(const char *s1, const char *s2);
; RDI = s1, RSI = s2
strcmp:
    MOV RCX, -1         ; Максимально возможная длина
    CLD                 ; Направление вперед
    
    REPE CMPSB          ; Сравниваем строки, пока байты равны
    JE .equal           ; Если все байты равны, строки равны
    
    MOV AL, [RDI-1]     ; Загружаем последние сравненные байты
    SUB AL, [RSI-1]
    MOVSX RAX, AL       ; Расширяем результат до 64 бит со знаком
    RET
    
.equal:
    XOR RAX, RAX        ; Возвращаем 0 (строки равны)
    RET
```

### Заполнение памяти (аналог memset)

```assembly
; void *memset(void *s, int c, size_t n);
; RDI = s, RSI = c, RDX = n
memset:
    MOV RCX, RDX        ; Копируем размер в RCX для REP
    MOV RAX, RSI        ; Значение для заполнения
    MOV AL, SIL         ; Берем только младший байт
    
    ; Оптимизация: заполняем 8 байт за раз
    MOV RSI, RAX
    MOV RDX, RAX
    SHL RSI, 8
    OR RAX, RSI         ; RAX = c | (c << 8) - два байта
    MOV RSI, RAX
    SHL RSI, 16
    OR RAX, RSI         ; RAX = повторяющийся байт c в 4 байтах
    MOV RSI, RAX
    SHL RSI, 32
    OR RAX, RSI         ; RAX = повторяющийся байт c в 8 байтах
    
    ; Проверяем, достаточно ли большой блок для оптимизации
    CMP RCX, 8
    JB .byte_fill       ; Если меньше 8 байт, заполняем побайтно
    
    ; Выравниваем назначение по 8 байт
    MOV RSI, RDI
    AND RSI, 7          ; RSI = RDI % 8 (остаток от деления на 8)
    JZ .aligned         ; Если уже выровнено, пропускаем
    
    MOV R8, 8
    SUB R8, RSI         ; R8 = количество байт до выравнивания
    SUB RCX, R8         ; Уменьшаем общий счетчик
    
    ; Заполняем байты до выравнивания
    CLD
    REP STOSB
    
.aligned:
    ; Заполняем по 8 байт
    MOV RSI, RCX
    SHR RSI, 3          ; RSI = RCX / 8
    MOV RCX, RSI
    REP STOSQ
    
    ; Заполняем оставшиеся байты
    MOV RCX, RDX
    AND RCX, 7          ; RCX = RDX % 8
    
.byte_fill:
    REP STOSB
    
    MOV RAX, RDI        ; Возвращаем указатель на заполненную память
    RET
```

## Примечания

1. Производительность:
   - Современные процессоры x86-64 оптимизированы для эффективного выполнения строковых инструкций
   - Для больших блоков данных строковые инструкции с префиксами REP могут быть эффективнее ручных циклов
   - Для очень больших блоков данных могут быть полезны неблокирующие инструкции (например, MOVNTQ)

2. Выравнивание:
   - Для оптимальной производительности данные должны быть выровнены по границе размера операнда
   - Невыровненный доступ может быть медленнее, особенно на старых процессорах

3. Направление:
   - Важно правильно устанавливать флаг направления (DF) перед использованием строковых инструкций
   - Многие функции ABI предполагают, что DF=0 при входе и выходе из функции

4. Ограничения:
   - Максимальный размер блока для одной операции REP ограничен значением RCX (2^64-1)
   - Для очень больших блоков может потребоваться разбиение на части