# Инструкции сдвига и поворота x86-64

Инструкции сдвига и поворота манипулируют битами операнда, перемещая их влево или вправо. Эти инструкции полезны для различных операций, включая умножение и деление на степени двойки, извлечение битовых полей и циклический сдвиг данных.

## Инструкции логического сдвига

### SHL/SAL - Логический/арифметический сдвиг влево

#### Синтаксис
```
SHL dest, count
SAL dest, count     ; Синоним SHL, оба работают одинаково
```

#### Описание
Сдвигает биты операнда влево на указанное количество позиций. Освободившиеся младшие биты заполняются нулями. Старшие биты, выдвигаемые за пределы операнда, помещаются в флаг CF.

#### Варианты
- `SHL r/m, 1` - Сдвиг на 1 бит
- `SHL r/m, CL` - Сдвиг на количество бит, указанное в регистре CL
- `SHL r/m, imm8` - Сдвиг на непосредственное значение (0-255)

#### Примеры
```assembly
SHL RAX, 1          ; RAX = RAX * 2, CF = старший бит RAX
SHL EBX, CL         ; EBX = EBX << CL
SHL WORD [RCX], 4   ; [RCX] = [RCX] << 4 (16-битная операция)
```

#### Флаги
- `CF` - устанавливается в значение последнего выдвинутого бита
- `OF` - устанавливается, если результат изменил знак (для сдвига на 1)
- `SF` - устанавливается, если результат отрицательный
- `ZF` - устанавливается, если результат равен нулю
- `PF` - устанавливается, если результат содержит четное число единичных битов
- `AF` - не определен

#### Применение
- Умножение на степени двойки (SHL RAX, n эквивалентно RAX = RAX * 2^n)
- Упаковка битовых полей
- Создание битовых масок

### SHR - Логический сдвиг вправо

#### Синтаксис
```
SHR dest, count
```

#### Описание
Сдвигает биты операнда вправо на указанное количество позиций. Освободившиеся старшие биты заполняются нулями. Младшие биты, выдвигаемые за пределы операнда, помещаются в флаг CF.

#### Варианты
- `SHR r/m, 1` - Сдвиг на 1 бит
- `SHR r/m, CL` - Сдвиг на количество бит, указанное в регистре CL
- `SHR r/m, imm8` - Сдвиг на непосредственное значение (0-255)

#### Примеры
```assembly
SHR RAX, 1          ; RAX = RAX / 2 (беззнаковое), CF = младший бит RAX
SHR EBX, CL         ; EBX = EBX >> CL (логический сдвиг)
SHR BYTE [RCX], 4   ; [RCX] = [RCX] >> 4 (8-битная операция)
```

#### Флаги
- `CF` - устанавливается в значение последнего выдвинутого бита
- `OF` - устанавливается, если изменился старший бит (для сдвига на 1)
- `SF` - устанавливается, если результат отрицательный
- `ZF` - устанавливается, если результат равен нулю
- `PF` - устанавливается, если результат содержит четное число единичных битов
- `AF` - не определен

#### Применение
- Деление на степени двойки для беззнаковых чисел (SHR RAX, n эквивалентно RAX = RAX / 2^n)
- Извлечение битовых полей
- Быстрое деление на 2

### SAR - Арифметический сдвиг вправо

#### Синтаксис
```
SAR dest, count
```

#### Описание
Сдвигает биты операнда вправо на указанное количество позиций. Освободившиеся старшие биты заполняются значением знакового бита (сохраняя знак числа). Младшие биты, выдвигаемые за пределы операнда, помещаются в флаг CF.

#### Варианты
- `SAR r/m, 1` - Сдвиг на 1 бит
- `SAR r/m, CL` - Сдвиг на количество бит, указанное в регистре CL
- `SAR r/m, imm8` - Сдвиг на непосредственное значение (0-255)

#### Примеры
```assembly
SAR RAX, 1          ; RAX = RAX / 2 (знаковое), CF = младший бит RAX
SAR EBX, CL         ; EBX = EBX >> CL (арифметический сдвиг)
SAR WORD [RCX], 4   ; [RCX] = [RCX] >> 4 (16-битная операция с сохранением знака)
```

#### Флаги
- `CF` - устанавливается в значение последнего выдвинутого бита
- `OF` - сбрасывается в 0 для сдвига на 1, не определен для других значений
- `SF` - устанавливается, если результат отрицательный
- `ZF` - устанавливается, если результат равен нулю
- `PF` - устанавливается, если результат содержит четное число единичных битов
- `AF` - не определен

#### Применение
- Деление на степени двойки для знаковых чисел
- Сохранение знака при сдвиге
- Знаковое расширение

## Инструкции циклического сдвига (поворота)

### ROL - Циклический сдвиг влево

#### Синтаксис
```
ROL dest, count
```

#### Описание
Циклически сдвигает биты операнда влево на указанное количество позиций. Биты, выдвигаемые слева, вставляются справа. Последний выдвинутый бит также помещается в флаг CF.

#### Варианты
- `ROL r/m, 1` - Сдвиг на 1 бит
- `ROL r/m, CL` - Сдвиг на количество бит, указанное в регистре CL
- `ROL r/m, imm8` - Сдвиг на непосредственное значение (0-255)

#### Примеры
```assembly
ROL RAX, 1          ; Циклический сдвиг RAX влево на 1 бит
ROL EBX, CL         ; Циклический сдвиг EBX влево на CL бит
ROL BYTE [RCX], 4   ; Циклический сдвиг байта по адресу [RCX] влево на 4 бита
```

#### Флаги
- `CF` - устанавливается в значение последнего выдвинутого бита
- `OF` - устанавливается, если операция изменила знак (для сдвига на 1)
- Остальные флаги не изменяются

#### Применение
- Циклический сдвиг данных
- Шифрование и хеширование
- Быстрое переупорядочивание битов

### ROR - Циклический сдвиг вправо

#### Синтаксис
```
ROR dest, count
```

#### Описание
Циклически сдвигает биты операнда вправо на указанное количество позиций. Биты, выдвигаемые справа, вставляются слева. Последний выдвинутый бит также помещается в флаг CF.

#### Варианты
- `ROR r/m, 1` - Сдвиг на 1 бит
- `ROR r/m, CL` - Сдвиг на количество бит, указанное в регистре CL
- `ROR r/m, imm8` - Сдвиг на непосредственное значение (0-255)

#### Примеры
```assembly
ROR RAX, 1          ; Циклический сдвиг RAX вправо на 1 бит
ROR EBX, CL         ; Циклический сдвиг EBX вправо на CL бит
ROR DWORD [RCX], 4  ; Циклический сдвиг двойного слова по адресу [RCX] вправо на 4 бита
```

#### Флаги
- `CF` - устанавливается в значение последнего выдвинутого бита
- `OF` - устанавливается, если операция изменила знак (для сдвига на 1)
- Остальные флаги не изменяются

#### Применение
- Циклический сдвиг данных
- Шифрование и хеширование
- Быстрое переупорядочивание битов

### RCL - Циклический сдвиг влево через перенос

#### Синтаксис
```
RCL dest, count
```

#### Описание
Циклически сдвигает биты операнда и флаг CF влево на указанное количество позиций. Биты, выдвигаемые слева, помещаются в CF, а предыдущее значение CF вставляется справа. Последний выдвинутый бит также помещается в флаг CF.

#### Варианты
- `RCL r/m, 1` - Сдвиг на 1 бит
- `RCL r/m, CL` - Сдвиг на количество бит, указанное в регистре CL
- `RCL r/m, imm8` - Сдвиг на непосредственное значение (0-255)

#### Примеры
```assembly
RCL RAX, 1          ; Циклический сдвиг RAX и CF влево на 1 бит
RCL EBX, CL         ; Циклический сдвиг EBX и CF влево на CL бит
RCL WORD [RCX], 4   ; Циклический сдвиг слова по адресу [RCX] и CF влево на 4 бита
```

#### Флаги
- `CF` - устанавливается в значение последнего выдвинутого бита
- `OF` - устанавливается, если операция изменила знак (для сдвига на 1)
- Остальные флаги не изменяются

#### Применение
- Многоразрядная арифметика
- Сложные операции сдвига
- Шифрование

### RCR - Циклический сдвиг вправо через перенос

#### Синтаксис
```
RCR dest, count
```

#### Описание
Циклически сдвигает биты операнда и флаг CF вправо на указанное количество позиций. Биты, выдвигаемые справа, помещаются в CF, а предыдущее значение CF вставляется слева. Последний выдвинутый бит также помещается в флаг CF.

#### Варианты
- `RCR r/m, 1` - Сдвиг на 1 бит
- `RCR r/m, CL` - Сдвиг на количество бит, указанное в регистре CL
- `RCR r/m, imm8` - Сдвиг на непосредственное значение (0-255)

#### Примеры
```assembly
RCR RAX, 1          ; Циклический сдвиг RAX и CF вправо на 1 бит
RCR EBX, CL         ; Циклический сдвиг EBX и CF вправо на CL бит
RCR DWORD [RCX], 4  ; Циклический сдвиг двойного слова по адресу [RCX] и CF вправо на 4 бита
```

#### Флаги
- `CF` - устанавливается в значение последнего выдвинутого бита
- `OF` - устанавливается, если операция изменила знак (для сдвига на 1)
- Остальные флаги не изменяются

#### Применение
- Многоразрядная арифметика
- Сложные операции сдвига
- Шифрование

## Инструкции сдвига для SIMD

### Сдвиги для упакованных целых чисел

```assembly
PSLLW xmm1, xmm2/m128/imm8    ; Логический сдвиг влево 8 слов
PSLLD xmm1, xmm2/m128/imm8    ; Логический сдвиг влево 4 двойных слов
PSLLQ xmm1, xmm2/m128/imm8    ; Логический сдвиг влево 2 четверных слов

PSRLW xmm1, xmm2/m128/imm8    ; Логический сдвиг вправо 8 слов
PSRLD xmm1, xmm2/m128/imm8    ; Логический сдвиг вправо 4 двойных слов
PSRLQ xmm1, xmm2/m128/imm8    ; Логический сдвиг вправо 2 четверных слов

PSRAW xmm1, xmm2/m128/imm8    ; Арифметический сдвиг вправо 8 слов
PSRAD xmm1, xmm2/m128/imm8    ; Арифметический сдвиг вправо 4 двойных слов
```

### Сдвиги для упакованных чисел с плавающей точкой

```assembly
PSLLDQ xmm1, imm8             ; Сдвиг влево на imm8 байт (заполнение нулями)
PSRLDQ xmm1, imm8             ; Сдвиг вправо на imm8 байт (заполнение нулями)
```

### Сдвиги AVX

```assembly
VPSLLW ymm1, ymm2, ymm3/m256/imm8    ; Логический сдвиг влево 16 слов
VPSLLD ymm1, ymm2, ymm3/m256/imm8    ; Логический сдвиг влево 8 двойных слов
VPSLLQ ymm1, ymm2, ymm3/m256/imm8    ; Логический сдвиг влево 4 четверных слов

VPSRLW ymm1, ymm2, ymm3/m256/imm8    ; Логический сдвиг вправо 16 слов
VPSRLD ymm1, ymm2, ymm3/m256/imm8    ; Логический сдвиг вправо 8 двойных слов
VPSRLQ ymm1, ymm2, ymm3/m256/imm8    ; Логический сдвиг вправо 4 четверных слов

VPSRAW ymm1, ymm2, ymm3/m256/imm8    ; Арифметический сдвиг вправо 16 слов
VPSRAD ymm1, ymm2, ymm3/m256/imm8    ; Арифметический сдвиг вправо 8 двойных слов
```

## Примечания

1. Инструкции сдвига часто используются для оптимизации:
   - Умножение на степени двойки: `SHL reg, n` вместо `IMUL reg, 2^n`
   - Деление на степени двойки: `SHR reg, n` (беззнаковое) или `SAR reg, n` (знаковое) вместо `DIV`
   - Быстрое умножение на 3, 5, 9: `LEA reg, [reg*2+reg]`, `LEA reg, [reg*4+reg]`, `LEA reg, [reg*8+reg]`

2. При сдвиге на количество бит, равное или большее размера операнда:
   - Для `SHL`/`SHR`/`SAR`: если count ≥ размер операнда, результат не определен
   - Для `ROL`/`ROR`/`RCL`/`RCR`: count фактически берется по модулю размера операнда (для 64-битных операндов - по модулю 64)

3. Для 64-битных операндов в режиме x86-64 используется только младшие 6 бит счетчика (count & 0x3F), так как 2^6 = 64.

4. Инструкции сдвига и поворота могут быть использованы для реализации различных алгоритмов шифрования и хеширования, таких как ROT13, CRC и части AES.

5. Для SIMD-инструкций сдвига важно помнить, что они работают с каждым элементом независимо, а не со всем регистром как единым целым (за исключением PSLLDQ и PSRLDQ).