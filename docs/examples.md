# Примеры использования инструкций x86-64

В этом разделе представлены практические примеры использования инструкций x86-64 для решения различных задач. Примеры демонстрируют типичные паттерны программирования на ассемблере и могут быть использованы как основа для собственных программ.

## Базовые примеры

### Пример 1: Вычисление факториала

```assembly
; Вычисление факториала числа в RAX
; Вход: RAX = n
; Выход: RAX = n!
factorial:
    cmp rax, 1          ; Проверка базового случая
    jbe .base_case      ; Если n <= 1, возвращаем 1
    
    push rbx            ; Сохраняем rbx
    mov rbx, rax        ; Сохраняем n в rbx
    dec rax             ; Вычисляем (n-1)
    call factorial      ; Рекурсивный вызов для (n-1)!
    mul rbx             ; RAX = RAX * RBX = (n-1)! * n
    pop rbx             ; Восстанавливаем rbx
    ret
    
.base_case:
    mov rax, 1          ; Возвращаем 1 для n <= 1
    ret
```

### Пример 2: Поиск максимального элемента в массиве

```assembly
; Поиск максимального элемента в массиве 32-битных целых чисел
; Вход: RDI = указатель на массив, RSI = количество элементов
; Выход: EAX = максимальный элемент
find_max:
    xor rax, rax        ; Обнуляем RAX
    test rsi, rsi       ; Проверяем, не пустой ли массив
    jz .done            ; Если массив пустой, возвращаем 0
    
    mov eax, [rdi]      ; Загружаем первый элемент как текущий максимум
    dec rsi             ; Уменьшаем счетчик (первый элемент уже обработан)
    add rdi, 4          ; Переходим к следующему элементу
    
.loop:
    test rsi, rsi       ; Проверяем, остались ли элементы
    jz .done            ; Если нет, завершаем
    
    cmp eax, [rdi]      ; Сравниваем текущий максимум с текущим элементом
    cmovl eax, [rdi]    ; Если текущий элемент больше, обновляем максимум
    
    dec rsi             ; Уменьшаем счетчик
    add rdi, 4          ; Переходим к следующему элементу
    jmp .loop           ; Повторяем цикл
    
.done:
    ret
```

### Пример 3: Копирование строки

```assembly
; Копирование строки с завершающим нулем
; Вход: RDI = указатель на строку назначения, RSI = указатель на исходную строку
; Выход: RDI = указатель на конец строки назначения
strcpy:
    push rdi            ; Сохраняем начальный указатель назначения
    
.loop:
    mov al, [rsi]       ; Загружаем текущий символ из исходной строки
    mov [rdi], al       ; Сохраняем символ в строке назначения
    inc rsi             ; Переходим к следующему символу в исходной строке
    inc rdi             ; Переходим к следующей позиции в строке назначения
    test al, al         ; Проверяем, не достигли ли конца строки (нулевой символ)
    jnz .loop           ; Если не конец, продолжаем цикл
    
    pop rax             ; Восстанавливаем начальный указатель назначения в RAX
    ret
```

### Пример 4: Подсчет количества установленных битов

```assembly
; Подсчет количества установленных битов в 64-битном числе
; Вход: RDI = число
; Выход: RAX = количество установленных битов
count_bits:
    xor rax, rax        ; Обнуляем счетчик
    
.loop:
    test rdi, rdi       ; Проверяем, остались ли биты для проверки
    jz .done            ; Если число стало 0, завершаем
    
    mov rcx, rdi        ; Копируем текущее значение
    and rcx, 1          ; Выделяем младший бит
    add rax, rcx        ; Добавляем его к счетчику
    
    shr rdi, 1          ; Сдвигаем число вправо на 1 бит
    jmp .loop           ; Повторяем цикл
    
.done:
    ret

; Альтернативная реализация с использованием POPCNT (если поддерживается)
count_bits_popcnt:
    popcnt rax, rdi     ; Подсчет битов с использованием POPCNT
    ret
```

## Примеры работы с памятью и строками

### Пример 5: Поиск подстроки (наивный алгоритм)

```assembly
; Поиск первого вхождения подстроки в строке
; Вход: RDI = указатель на строку, RSI = указатель на подстроку
; Выход: RAX = указатель на первое вхождение или 0, если не найдено
strstr:
    push rbx            ; Сохраняем используемые регистры
    push r12
    push r13
    
    mov r12, rdi        ; r12 = указатель на текущую позицию в строке
    mov r13, rsi        ; r13 = указатель на подстроку
    
.outer_loop:
    mov al, [r12]       ; Загружаем текущий символ строки
    test al, al         ; Проверяем на конец строки
    jz .not_found       ; Если конец строки, подстрока не найдена
    
    mov rdi, r12        ; rdi = текущая позиция в строке
    mov rsi, r13        ; rsi = начало подстроки
    
.inner_loop:
    mov al, [rsi]       ; Загружаем текущий символ подстроки
    test al, al         ; Проверяем на конец подстроки
    jz .found           ; Если конец подстроки, значит нашли совпадение
    
    mov bl, [rdi]       ; Загружаем соответствующий символ строки
    test bl, bl         ; Проверяем на конец строки
    jz .not_found       ; Если конец строки, подстрока не найдена
    
    cmp al, bl          ; Сравниваем символы
    jne .mismatch       ; Если не совпадают, прерываем внутренний цикл
    
    inc rdi             ; Переходим к следующему символу строки
    inc rsi             ; Переходим к следующему символу подстроки
    jmp .inner_loop     ; Продолжаем внутренний цикл
    
.mismatch:
    inc r12             ; Переходим к следующей позиции в строке
    jmp .outer_loop     ; Продолжаем внешний цикл
    
.found:
    mov rax, r12        ; Возвращаем указатель на начало найденной подстроки
    jmp .done
    
.not_found:
    xor rax, rax        ; Возвращаем 0 (не найдено)
    
.done:
    pop r13             ; Восстанавливаем регистры
    pop r12
    pop rbx
    ret
```

### Пример 6: Реализация memset

```assembly
; Заполнение блока памяти заданным значением
; Вход: RDI = указатель на блок памяти, RSI = значение (байт), RDX = размер блока
; Выход: RDI = указатель на блок памяти (исходный)
memset:
    push rdi            ; Сохраняем исходный указатель
    
    ; Оптимизация: заполняем по 8 байт за раз
    mov rcx, rdx        ; rcx = размер
    mov al, sil         ; al = значение для заполнения
    
    ; Дублируем значение во все байты RAX
    movzx rax, al       ; Расширяем до 64 бит с нулями
    mov ah, al          ; ax = al | (al << 8)
    mov r8, rax         ; Копируем в r8
    shl r8, 16          ; r8 = ax << 16
    or rax, r8          ; rax = ax | (ax << 16) - заполнены младшие 32 бита
    mov r8, rax         ; Копируем в r8
    shl r8, 32          ; r8 = eax << 32
    or rax, r8          ; rax = eax | (eax << 32) - заполнены все 64 бита
    
    ; Проверяем, достаточно ли большой блок для оптимизации
    cmp rcx, 8
    jb .byte_fill       ; Если меньше 8 байт, заполняем побайтно
    
    ; Выравниваем адрес по 8 байт
    mov r8, rdi
    and r8, 7           ; r8 = rdi % 8 (остаток от деления на 8)
    jz .aligned         ; Если уже выровнено, пропускаем
    
    mov r9, 8
    sub r9, r8          ; r9 = количество байт до выравнивания
    sub rcx, r9         ; Уменьшаем общий счетчик
    
    ; Заполняем байты до выравнивания
.align_loop:
    mov [rdi], al       ; Записываем байт
    inc rdi             ; Переходим к следующему байту
    dec r9              ; Уменьшаем счетчик выравнивания
    jnz .align_loop     ; Продолжаем, пока не выровняем
    
.aligned:
    ; Заполняем по 8 байт за раз
    mov r8, rcx
    shr r8, 3           ; r8 = rcx / 8
    
.qword_loop:
    mov [rdi], rax      ; Записываем 8 байт
    add rdi, 8          ; Переходим к следующим 8 байтам
    dec r8              ; Уменьшаем счетчик
    jnz .qword_loop     ; Продолжаем цикл
    
    ; Заполняем оставшиеся байты
    and rcx, 7          ; rcx = rcx % 8
    
.byte_fill:
    test rcx, rcx       ; Проверяем, остались ли байты для заполнения
    jz .done            ; Если нет, завершаем
    
    mov [rdi], al       ; Записываем байт
    inc rdi             ; Переходим к следующему байту
    dec rcx             ; Уменьшаем счетчик
    jmp .byte_fill      ; Повторяем цикл
    
.done:
    pop rax             ; Восстанавливаем и возвращаем исходный указатель
    ret
```

### Пример 7: Быстрое копирование блока памяти

```assembly
; Копирование блока памяти
; Вход: RDI = указатель на блок назначения, RSI = указатель на исходный блок, RDX = размер блока
; Выход: RDI = указатель на блок назначения (исходный)
memcpy:
    push rdi            ; Сохраняем исходный указатель назначения
    
    ; Проверяем перекрытие блоков
    mov rax, rdi
    sub rax, rsi        ; rax = dest - src
    cmp rax, rdx        ; Если (dest - src) < size, блоки перекрываются и нужно копировать в обратном порядке
    jb .backwards
    
    ; Копирование вперед
    ; Оптимизация: копируем по 8 байт за раз
    mov rcx, rdx        ; rcx = размер
    
    ; Проверяем, достаточно ли большой блок для оптимизации
    cmp rcx, 8
    jb .byte_copy_forward  ; Если меньше 8 байт, копируем побайтно
    
    ; Выравниваем адрес назначения по 8 байт
    mov r8, rdi
    and r8, 7           ; r8 = rdi % 8 (остаток от деления на 8)
    jz .aligned_forward ; Если уже выровнено, пропускаем
    
    mov r9, 8
    sub r9, r8          ; r9 = количество байт до выравнивания
    sub rcx, r9         ; Уменьшаем общий счетчик
    
    ; Копируем байты до выравнивания
.align_loop_forward:
    mov al, [rsi]       ; Загружаем байт из источника
    mov [rdi], al       ; Сохраняем байт в назначении
    inc rsi             ; Переходим к следующему байту источника
    inc rdi             ; Переходим к следующему байту назначения
    dec r9              ; Уменьшаем счетчик выравнивания
    jnz .align_loop_forward  ; Продолжаем, пока не выровняем
    
.aligned_forward:
    ; Копируем по 8 байт за раз
    mov r8, rcx
    shr r8, 3           ; r8 = rcx / 8
    
.qword_loop_forward:
    mov rax, [rsi]      ; Загружаем 8 байт из источника
    mov [rdi], rax      ; Сохраняем 8 байт в назначении
    add rsi, 8          ; Переходим к следующим 8 байтам источника
    add rdi, 8          ; Переходим к следующим 8 байтам назначения
    dec r8              ; Уменьшаем счетчик
    jnz .qword_loop_forward  ; Продолжаем цикл
    
    ; Копируем оставшиеся байты
    and rcx, 7          ; rcx = rcx % 8
    
.byte_copy_forward:
    test rcx, rcx       ; Проверяем, остались ли байты для копирования
    jz .done            ; Если нет, завершаем
    
    mov al, [rsi]       ; Загружаем байт из источника
    mov [rdi], al       ; Сохраняем байт в назначении
    inc rsi             ; Переходим к следующему байту источника
    inc rdi             ; Переходим к следующему байту назначения
    dec rcx             ; Уменьшаем счетчик
    jmp .byte_copy_forward  ; Повторяем цикл
    
.backwards:
    ; Копирование назад (для перекрывающихся блоков)
    add rsi, rdx        ; Переходим к концу исходного блока
    add rdi, rdx        ; Переходим к концу блока назначения
    mov rcx, rdx        ; rcx = размер
    
    ; Проверяем, достаточно ли большой блок для оптимизации
    cmp rcx, 8
    jb .byte_copy_backward  ; Если меньше 8 байт, копируем побайтно
    
    ; Выравниваем адрес назначения по 8 байт
    mov r8, rdi
    and r8, 7           ; r8 = rdi % 8 (остаток от деления на 8)
    jz .aligned_backward  ; Если уже выровнено, пропускаем
    
    ; Копируем байты до выравнивания
.align_loop_backward:
    dec rsi             ; Переходим к предыдущему байту источника
    dec rdi             ; Переходим к предыдущему байту назначения
    mov al, [rsi]       ; Загружаем байт из источника
    mov [rdi], al       ; Сохраняем байт в назначении
    dec rcx             ; Уменьшаем счетчик
    dec r8              ; Уменьшаем счетчик выравнивания
    jnz .align_loop_backward  ; Продолжаем, пока не выровняем
    
.aligned_backward:
    ; Копируем по 8 байт за раз
    mov r8, rcx
    shr r8, 3           ; r8 = rcx / 8
    
.qword_loop_backward:
    sub rsi, 8          ; Переходим к предыдущим 8 байтам источника
    sub rdi, 8          ; Переходим к предыдущим 8 байтам назначения
    mov rax, [rsi]      ; Загружаем 8 байт из источника
    mov [rdi], rax      ; Сохраняем 8 байт в назначении
    dec r8              ; Уменьшаем счетчик
    jnz .qword_loop_backward  ; Продолжаем цикл
    
    ; Копируем оставшиеся байты
    and rcx, 7          ; rcx = rcx % 8
    
.byte_copy_backward:
    test rcx, rcx       ; Проверяем, остались ли байты для копирования
    jz .done            ; Если нет, завершаем
    
    dec rsi             ; Переходим к предыдущему байту источника
    dec rdi             ; Переходим к предыдущему байту назначения
    mov al, [rsi]       ; Загружаем байт из источника
    mov [rdi], al       ; Сохраняем байт в назначении
    dec rcx             ; Уменьшаем счетчик
    jmp .byte_copy_backward  ; Повторяем цикл
    
.done:
    pop rax             ; Восстанавливаем и возвращаем исходный указатель назначения
    ret
```

## Примеры работы с числами

### Пример 8: Быстрое возведение в степень

```assembly
; Быстрое возведение в степень (алгоритм бинарного возведения)
; Вход: RDI = основание, RSI = показатель степени
; Выход: RAX = результат (RDI^RSI)
power:
    mov rax, 1          ; Инициализируем результат единицей
    
    test rsi, rsi       ; Проверяем, не равен ли показатель нулю
    jz .done            ; Если равен, возвращаем 1
    
.loop:
    test rsi, 1         ; Проверяем младший бит показателя
    jz .skip            ; Если бит не установлен, пропускаем умножение
    
    mul rdi             ; rax = rax * rdi
    
.skip:
    shl rdi, 1          ; rdi = rdi * 2 (возводим основание в квадрат)
    shr rsi, 1          ; rsi = rsi / 2 (уменьшаем показатель вдвое)
    
    test rsi, rsi       ; Проверяем, не стал ли показатель нулем
    jnz .loop           ; Если не стал, продолжаем цикл
    
.done:
    ret
```

### Пример 9: Вычисление наибольшего общего делителя (алгоритм Евклида)

```assembly
; Вычисление наибольшего общего делителя (НОД) двух чисел
; Вход: RDI = первое число, RSI = второе число
; Выход: RAX = НОД(RDI, RSI)
gcd:
    test rsi, rsi       ; Проверяем, не равно ли второе число нулю
    jz .done            ; Если равно, возвращаем первое число
    
    mov rax, rdi        ; rax = первое число
    xor rdx, rdx        ; Очищаем rdx для деления
    div rsi             ; rax = rdi / rsi, rdx = rdi % rsi
    
    mov rdi, rsi        ; Первое число = второе число
    mov rsi, rdx        ; Второе число = остаток от деления
    
    jmp gcd             ; Рекурсивный вызов
    
.done:
    mov rax, rdi        ; Возвращаем первое число
    ret
```

### Пример 10: Проверка числа на простоту (метод пробных делений)

```assembly
; Проверка числа на простоту
; Вход: RDI = проверяемое число
; Выход: RAX = 1, если число простое, 0 иначе
is_prime:
    cmp rdi, 2          ; Проверяем, не равно ли число 2
    je .prime           ; Если равно, возвращаем 1 (простое)
    
    cmp rdi, 2          ; Проверяем, не меньше ли число 2
    jb .not_prime       ; Если меньше, возвращаем 0 (не простое)
    
    test rdi, 1         ; Проверяем, не четное ли число
    jz .not_prime       ; Если четное (кроме 2), возвращаем 0 (не простое)
    
    mov rcx, 3          ; Начинаем проверку с делителя 3
    
.loop:
    mov rax, rcx        ; Копируем текущий делитель в rax
    mul rax             ; rax = rax * rax (квадрат делителя)
    
    cmp rax, rdi        ; Сравниваем квадрат делителя с числом
    ja .prime           ; Если больше, число простое
    
    mov rax, rdi        ; Копируем число в rax
    xor rdx, rdx        ; Очищаем rdx для деления
    div rcx             ; rax = rdi / rcx, rdx = rdi % rcx
    
    test rdx, rdx       ; Проверяем, не равен ли остаток нулю
    jz .not_prime       ; Если равен, число не простое
    
    add rcx, 2          ; Переходим к следующему нечетному делителю
    jmp .loop           ; Повторяем цикл
    
.prime:
    mov rax, 1          ; Возвращаем 1 (число простое)
    ret
    
.not_prime:
    xor rax, rax        ; Возвращаем 0 (число не простое)
    ret
```

## Примеры работы с SIMD

### Пример 11: Векторное сложение массивов чисел с плавающей точкой

```assembly
; Векторное сложение двух массивов чисел с плавающей точкой
; Вход: RDI = указатель на первый массив, RSI = указатель на второй массив,
;       RDX = указатель на массив результатов, RCX = количество элементов
; Выход: нет
vector_add_float:
    test rcx, rcx       ; Проверяем, не пустые ли массивы
    jz .done            ; Если пустые, завершаем
    
    ; Проверяем, поддерживается ли AVX
    push rax
    push rbx
    push rcx
    push rdx
    
    mov eax, 1          ; Функция CPUID для проверки возможностей
    cpuid
    and ecx, 0x10000000 ; Проверяем бит 28 (AVX)
    
    pop rdx
    pop rcx
    pop rbx
    pop rax
    
    jnz .use_avx        ; Если AVX поддерживается, используем его
    
    ; Используем SSE
.use_sse:
    mov r8, rcx         ; Копируем счетчик
    shr r8, 2           ; r8 = rcx / 4 (количество блоков по 4 элемента)
    
    test r8, r8         ; Проверяем, есть ли полные блоки
    jz .sse_remainder   ; Если нет, переходим к оставшимся элементам
    
.sse_loop:
    movaps xmm0, [rdi]  ; Загружаем 4 элемента из первого массива
    addps xmm0, [rsi]   ; Складываем с 4 элементами из второго массива
    movaps [rdx], xmm0  ; Сохраняем результат
    
    add rdi, 16         ; Переходим к следующим 4 элементам первого массива
    add rsi, 16         ; Переходим к следующим 4 элементам второго массива
    add rdx, 16         ; Переходим к следующим 4 элементам результата
    
    dec r8              ; Уменьшаем счетчик блоков
    jnz .sse_loop       ; Повторяем цикл
    
.sse_remainder:
    and rcx, 3          ; rcx = rcx % 4 (оставшиеся элементы)
    
    test rcx, rcx       ; Проверяем, остались ли элементы
    jz .done            ; Если нет, завершаем
    
.sse_remainder_loop:
    movss xmm0, [rdi]   ; Загружаем один элемент из первого массива
    addss xmm0, [rsi]   ; Складываем с одним элементом из второго массива
    movss [rdx], xmm0   ; Сохраняем результат
    
    add rdi, 4          ; Переходим к следующему элементу первого массива
    add rsi, 4          ; Переходим к следующему элементу второго массива
    add rdx, 4          ; Переходим к следующему элементу результата
    
    dec rcx             ; Уменьшаем счетчик
    jnz .sse_remainder_loop  ; Повторяем цикл
    
    jmp .done           ; Завершаем
    
.use_avx:
    mov r8, rcx         ; Копируем счетчик
    shr r8, 3           ; r8 = rcx / 8 (количество блоков по 8 элементов)
    
    test r8, r8         ; Проверяем, есть ли полные блоки
    jz .avx_remainder   ; Если нет, переходим к оставшимся элементам
    
.avx_loop:
    vmovaps ymm0, [rdi] ; Загружаем 8 элементов из первого массива
    vaddps ymm0, ymm0, [rsi]  ; Складываем с 8 элементами из второго массива
    vmovaps [rdx], ymm0 ; Сохраняем результат
    
    add rdi, 32         ; Переходим к следующим 8 элементам первого массива
    add rsi, 32         ; Переходим к следующим 8 элементам второго массива
    add rdx, 32         ; Переходим к следующим 8 элементам результата
    
    dec r8              ; Уменьшаем счетчик блоков
    jnz .avx_loop       ; Повторяем цикл
    
.avx_remainder:
    and rcx, 7          ; rcx = rcx % 8 (оставшиеся элементы)
    
    test rcx, rcx       ; Проверяем, остались ли элементы
    jz .avx_done        ; Если нет, завершаем
    
    ; Обрабатываем оставшиеся элементы с помощью SSE
    mov r8, rcx         ; Копируем счетчик
    shr r8, 2           ; r8 = rcx / 4 (количество блоков по 4 элемента)
    
    test r8, r8         ; Проверяем, есть ли полные блоки
    jz .avx_remainder_single  ; Если нет, переходим к отдельным элементам
    
.avx_remainder_sse:
    movaps xmm0, [rdi]  ; Загружаем 4 элемента из первого массива
    addps xmm0, [rsi]   ; Складываем с 4 элементами из второго массива
    movaps [rdx], xmm0  ; Сохраняем результат
    
    add rdi, 16         ; Переходим к следующим 4 элементам первого массива
    add rsi, 16         ; Переходим к следующим 4 элементам второго массива
    add rdx, 16         ; Переходим к следующим 4 элементам результата
    
    dec r8              ; Уменьшаем счетчик блоков
    jnz .avx_remainder_sse  ; Повторяем цикл
    
.avx_remainder_single:
    and rcx, 3          ; rcx = rcx % 4 (оставшиеся элементы)
    
    test rcx, rcx       ; Проверяем, остались ли элементы
    jz .avx_done        ; Если нет, завершаем
    
.avx_remainder_loop:
    movss xmm0, [rdi]   ; Загружаем один элемент из первого массива
    addss xmm0, [rsi]   ; Складываем с одним элементом из второго массива
    movss [rdx], xmm0   ; Сохраняем результат
    
    add rdi, 4          ; Переходим к следующему элементу первого массива
    add rsi, 4          ; Переходим к следующему элементу второго массива
    add rdx, 4          ; Переходим к следующему элементу результата
    
    dec rcx             ; Уменьшаем счетчик
    jnz .avx_remainder_loop  ; Повторяем цикл
    
.avx_done:
    vzeroupper          ; Очищаем верхние части регистров YMM
    
.done:
    ret
```

### Пример 12: Вычисление скалярного произведения векторов

```assembly
; Вычисление скалярного произведения двух векторов
; Вход: RDI = указатель на первый вектор, RSI = указатель на второй вектор,
;       RDX = количество элементов
; Выход: XMM0 = скалярное произведение
dot_product:
    xorps xmm0, xmm0    ; Обнуляем аккумулятор
    
    test rdx, rdx       ; Проверяем, не пустые ли векторы
    jz .done            ; Если пустые, возвращаем 0
    
    ; Проверяем, поддерживается ли AVX
    push rax
    push rbx
    push rcx
    push rdx
    
    mov eax, 1          ; Функция CPUID для проверки возможностей
    cpuid
    and ecx, 0x10000000 ; Проверяем бит 28 (AVX)
    
    pop rdx
    pop rcx
    pop rbx
    pop rax
    
    jnz .use_avx        ; Если AVX поддерживается, используем его
    
    ; Используем SSE
.use_sse:
    mov rcx, rdx        ; Копируем счетчик
    shr rcx, 2          ; rcx = rdx / 4 (количество блоков по 4 элемента)
    
    test rcx, rcx       ; Проверяем, есть ли полные блоки
    jz .sse_remainder   ; Если нет, переходим к оставшимся элементам
    
.sse_loop:
    movaps xmm1, [rdi]  ; Загружаем 4 элемента из первого вектора
    mulps xmm1, [rsi]   ; Умножаем на 4 элемента из второго вектора
    addps xmm0, xmm1    ; Добавляем к аккумулятору
    
    add rdi, 16         ; Переходим к следующим 4 элементам первого вектора
    add rsi, 16         ; Переходим к следующим 4 элементам второго вектора
    
    dec rcx             ; Уменьшаем счетчик блоков
    jnz .sse_loop       ; Повторяем цикл
    
    ; Горизонтальное сложение элементов аккумулятора
    haddps xmm0, xmm0   ; xmm0 = [xmm0[0]+xmm0[1], xmm0[2]+xmm0[3], xmm0[0]+xmm0[1], xmm0[2]+xmm0[3]]
    haddps xmm0, xmm0   ; xmm0 = [xmm0[0]+xmm0[1], xmm0[0]+xmm0[1], xmm0[0]+xmm0[1], xmm0[0]+xmm0[1]]
    
.sse_remainder:
    and rdx, 3          ; rdx = rdx % 4 (оставшиеся элементы)
    
    test rdx, rdx       ; Проверяем, остались ли элементы
    jz .done            ; Если нет, завершаем
    
.sse_remainder_loop:
    movss xmm1, [rdi]   ; Загружаем один элемент из первого вектора
    mulss xmm1, [rsi]   ; Умножаем на один элемент из второго вектора
    addss xmm0, xmm1    ; Добавляем к аккумулятору
    
    add rdi, 4          ; Переходим к следующему элементу первого вектора
    add rsi, 4          ; Переходим к следующему элементу второго вектора
    
    dec rdx             ; Уменьшаем счетчик
    jnz .sse_remainder_loop  ; Повторяем цикл
    
    jmp .done           ; Завершаем
    
.use_avx:
    vxorps ymm0, ymm0, ymm0  ; Обнуляем аккумулятор
    
    mov rcx, rdx        ; Копируем счетчик
    shr rcx, 3          ; rcx = rdx / 8 (количество блоков по 8 элементов)
    
    test rcx, rcx       ; Проверяем, есть ли полные блоки
    jz .avx_remainder   ; Если нет, переходим к оставшимся элементам
    
.avx_loop:
    vmovaps ymm1, [rdi] ; Загружаем 8 элементов из первого вектора
    vmulps ymm1, ymm1, [rsi]  ; Умножаем на 8 элементов из второго вектора
    vaddps ymm0, ymm0, ymm1   ; Добавляем к аккумулятору
    
    add rdi, 32         ; Переходим к следующим 8 элементам первого вектора
    add rsi, 32         ; Переходим к следующим 8 элементам второго вектора
    
    dec rcx             ; Уменьшаем счетчик блоков
    jnz .avx_loop       ; Повторяем цикл
    
    ; Горизонтальное сложение элементов аккумулятора
    vextractf128 xmm1, ymm0, 1  ; Извлекаем верхнюю половину ymm0
    vaddps xmm0, xmm0, xmm1     ; Складываем нижнюю и верхнюю половины
    vhaddps xmm0, xmm0, xmm0    ; Горизонтальное сложение
    vhaddps xmm0, xmm0, xmm0    ; Еще раз горизонтальное сложение
    
.avx_remainder:
    and rdx, 7          ; rdx = rdx % 8 (оставшиеся элементы)
    
    test rdx, rdx       ; Проверяем, остались ли элементы
    jz .avx_done        ; Если нет, завершаем
    
.avx_remainder_loop:
    vmovss xmm1, [rdi]  ; Загружаем один элемент из первого вектора
    vmulss xmm1, xmm1, [rsi]  ; Умножаем на один элемент из второго вектора
    vaddss xmm0, xmm0, xmm1   ; Добавляем к аккумулятору
    
    add rdi, 4          ; Переходим к следующему элементу первого вектора
    add rsi, 4          ; Переходим к следующему элементу второго вектора
    
    dec rdx             ; Уменьшаем счетчик
    jnz .avx_remainder_loop  ; Повторяем цикл
    
.avx_done:
    vzeroupper          ; Очищаем верхние части регистров YMM
    
.done:
    ret
```

## Примеры системного программирования

### Пример 13: Системный вызов для записи в файл (Linux)

```assembly
; Запись строки в файловый дескриптор (Linux)
; Вход: RDI = файловый дескриптор, RSI = указатель на строку, RDX = длина строки
; Выход: RAX = количество записанных байт или код ошибки
write_to_fd:
    mov rax, 1          ; Системный вызов sys_write
    syscall             ; Вызов ядра
    ret
```

### Пример 14: Системный вызов для чтения из файла (Linux)

```assembly
; Чтение из файлового дескриптора в буфер (Linux)
; Вход: RDI = файловый дескриптор, RSI = указатель на буфер, RDX = размер буфера
; Выход: RAX = количество прочитанных байт или код ошибки
read_from_fd:
    mov rax, 0          ; Системный вызов sys_read
    syscall             ; Вызов ядра
    ret
```

### Пример 15: Измерение времени выполнения кода

```assembly
; Измерение времени выполнения кода
; Вход: RDI = указатель на функцию для измерения, RSI, RDX, RCX, R8, R9 = аргументы функции
; Выход: RAX = время выполнения в тактах процессора
measure_time:
    push rbp            ; Сохраняем регистры
    mov rbp, rsp
    push rbx
    push r12
    push r13
    push r14
    push r15
    
    mov r12, rdi        ; Сохраняем указатель на функцию
    mov r13, rsi        ; Сохраняем первый аргумент
    mov r14, rdx        ; Сохраняем второй аргумент
    mov r15, rcx        ; Сохраняем третий аргумент
    
    ; Сохраняем остальные аргументы на стеке
    push r9
    push r8
    
    ; Измеряем начальное время
    rdtsc               ; Чтение счетчика временных меток
    shl rdx, 32         ; Сдвигаем старшие 32 бита
    or rax, rdx         ; Объединяем с младшими 32 битами
    mov rbx, rax        ; Сохраняем начальное время
    
    ; Вызываем измеряемую функцию
    pop r8              ; Восстанавливаем пятый аргумент
    pop r9              ; Восстанавливаем шестой аргумент
    
    mov rdi, r13        ; Устанавливаем первый аргумент
    mov rsi, r14        ; Устанавливаем второй аргумент
    mov rdx, r15        ; Устанавливаем третий аргумент
    
    call r12            ; Вызываем функцию
    
    ; Измеряем конечное время
    rdtsc               ; Чтение счетчика временных меток
    shl rdx, 32         ; Сдвигаем старшие 32 бита
    or rax, rdx         ; Объединяем с младшими 32 битами
    
    sub rax, rbx        ; Вычисляем разницу (время выполнения)
    
    ; Восстанавливаем регистры и возвращаемся
    pop r15
    pop r14
    pop r13
    pop r12
    pop rbx
    pop rbp
    ret
```

## Примечания

1. Приведенные примеры демонстрируют различные техники программирования на ассемблере x86-64, но могут требовать адаптации для конкретных компиляторов и операционных систем.

2. Некоторые примеры используют расширения процессора (например, AVX), которые могут быть недоступны на старых процессорах. В реальном коде следует проверять поддержку этих расширений с помощью CPUID.

3. Системные вызовы в примерах 13 и 14 специфичны для Linux. Для других операционных систем (Windows, macOS) нужно использовать соответствующие системные вызовы и соглашения о вызовах.

4. В примерах используется AT&T синтаксис ассемблера. Для синтаксиса Intel некоторые инструкции и порядок операндов будут отличаться.

5. Для оптимальной производительности следует учитывать особенности конкретной микроархитектуры процессора (конвейеризация, предсказание переходов, кэширование и т.д.).