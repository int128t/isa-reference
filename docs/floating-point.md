# Инструкции для работы с плавающей точкой x86-64

Архитектура x86-64 поддерживает несколько наборов инструкций для работы с числами с плавающей точкой, которые развивались с течением времени:

1. **x87 FPU** - оригинальный набор инструкций для работы с плавающей точкой
2. **SSE/SSE2** - расширения для работы с одиночной и двойной точностью
3. **AVX/AVX2/AVX-512** - расширенные векторные инструкции

В этом документе мы сосредоточимся на основных инструкциях для работы с плавающей точкой.

## x87 FPU инструкции

x87 FPU использует стековую модель с 8 регистрами (ST0-ST7), организованными как стек. ST0 - вершина стека.

### Загрузка и сохранение данных

#### FLD - Загрузка значения с плавающей точкой

##### Синтаксис
```
FLD src
```

##### Описание
Загружает значение с плавающей точкой из источника в вершину стека FPU (ST0), сдвигая предыдущие значения вниз.

##### Варианты
- `FLD m32fp` - Загрузка 32-битного значения с плавающей точкой
- `FLD m64fp` - Загрузка 64-битного значения с плавающей точкой
- `FLD m80fp` - Загрузка 80-битного значения с плавающей точкой
- `FLD ST(i)` - Копирование значения из регистра ST(i) в ST(0)

##### Примеры
```assembly
FLD DWORD [RBX]     ; Загружает 32-битное значение из памяти в ST0
FLD QWORD [RAX+8]   ; Загружает 64-битное значение из памяти в ST0
FLD ST1             ; Копирует ST1 в ST0, сдвигая стек
```

#### FST/FSTP - Сохранение значения с плавающей точкой

##### Синтаксис
```
FST dest            ; Сохранение без выталкивания из стека
FSTP dest           ; Сохранение с выталкиванием из стека
```

##### Описание
Сохраняет значение с вершины стека FPU (ST0) в приемник. FSTP также выталкивает значение из стека.

##### Варианты
- `FST/FSTP m32fp` - Сохранение в 32-битное значение с плавающей точкой
- `FST/FSTP m64fp` - Сохранение в 64-битное значение с плавающей точкой
- `FSTP m80fp` - Сохранение в 80-битное значение с плавающей точкой
- `FST/FSTP ST(i)` - Копирование значения из ST(0) в регистр ST(i)

##### Примеры
```assembly
FST DWORD [RDI]     ; Сохраняет ST0 в 32-битное значение в памяти
FSTP QWORD [RSI]    ; Сохраняет ST0 в 64-битное значение в памяти и выталкивает из стека
FSTP ST1            ; Копирует ST0 в ST1 и выталкивает ST0
```

### Арифметические операции

#### FADD/FADDP - Сложение

##### Синтаксис
```
FADD src            ; ST0 = ST0 + src
FADD dest, ST0      ; dest = dest + ST0
FADDP dest, ST0     ; dest = dest + ST0, затем выталкивает ST0
```

##### Описание
Складывает значения с плавающей точкой.

##### Примеры
```assembly
FADD ST1            ; ST0 = ST0 + ST1
FADD DWORD [RBX]    ; ST0 = ST0 + [RBX]
FADDP ST1, ST0      ; ST1 = ST1 + ST0, затем выталкивает ST0
```

#### FSUB/FSUBP/FSUBR/FSUBRP - Вычитание

##### Синтаксис
```
FSUB src            ; ST0 = ST0 - src
FSUB dest, ST0      ; dest = dest - ST0
FSUBP dest, ST0     ; dest = dest - ST0, затем выталкивает ST0
FSUBR src           ; ST0 = src - ST0 (обратное вычитание)
FSUBR dest, ST0     ; dest = ST0 - dest (обратное вычитание)
FSUBRP dest, ST0    ; dest = ST0 - dest, затем выталкивает ST0
```

##### Описание
Вычитает значения с плавающей точкой. Варианты FSUBR выполняют вычитание в обратном порядке.

##### Примеры
```assembly
FSUB ST2            ; ST0 = ST0 - ST2
FSUBR QWORD [RAX]   ; ST0 = [RAX] - ST0
FSUBP ST3, ST0      ; ST3 = ST3 - ST0, затем выталкивает ST0
```

#### FMUL/FMULP - Умножение

##### Синтаксис
```
FMUL src            ; ST0 = ST0 * src
FMUL dest, ST0      ; dest = dest * ST0
FMULP dest, ST0     ; dest = dest * ST0, затем выталкивает ST0
```

##### Описание
Умножает значения с плавающей точкой.

##### Примеры
```assembly
FMUL ST1            ; ST0 = ST0 * ST1
FMUL DWORD [RBX]    ; ST0 = ST0 * [RBX]
FMULP ST1, ST0      ; ST1 = ST1 * ST0, затем выталкивает ST0
```

#### FDIV/FDIVP/FDIVR/FDIVRP - Деление

##### Синтаксис
```
FDIV src            ; ST0 = ST0 / src
FDIV dest, ST0      ; dest = dest / ST0
FDIVP dest, ST0     ; dest = dest / ST0, затем выталкивает ST0
FDIVR src           ; ST0 = src / ST0 (обратное деление)
FDIVR dest, ST0     ; dest = ST0 / dest (обратное деление)
FDIVRP dest, ST0    ; dest = ST0 / dest, затем выталкивает ST0
```

##### Описание
Делит значения с плавающей точкой. Варианты FDIVR выполняют деление в обратном порядке.

##### Примеры
```assembly
FDIV ST2            ; ST0 = ST0 / ST2
FDIVR QWORD [RAX]   ; ST0 = [RAX] / ST0
FDIVP ST3, ST0      ; ST3 = ST3 / ST0, затем выталкивает ST0
```

### Сравнение и управление стеком

#### FCOM/FCOMP/FCOMPP - Сравнение

##### Синтаксис
```
FCOM src            ; Сравнивает ST0 с src
FCOMP src           ; Сравнивает ST0 с src, затем выталкивает ST0
FCOMPP              ; Сравнивает ST0 с ST1, затем выталкивает ST0 и ST1
```

##### Описание
Сравнивает значения с плавающей точкой и устанавливает флаги FPU.

##### Примеры
```assembly
FCOM ST2            ; Сравнивает ST0 с ST2
FCOMP QWORD [RBX]   ; Сравнивает ST0 с [RBX], затем выталкивает ST0
FCOMPP              ; Сравнивает ST0 с ST1, затем выталкивает оба
```

#### FCOMI/FCOMIP - Сравнение с установкой флагов EFLAGS

##### Синтаксис
```
FCOMI ST0, ST(i)    ; Сравнивает ST0 с ST(i) и устанавливает флаги EFLAGS
FCOMIP ST0, ST(i)   ; Сравнивает ST0 с ST(i), устанавливает флаги EFLAGS, затем выталкивает ST0
```

##### Описание
Сравнивает значения с плавающей точкой и устанавливает флаги EFLAGS (ZF, PF, CF).

##### Примеры
```assembly
FCOMI ST0, ST2      ; Сравнивает ST0 с ST2, устанавливает флаги
FCOMIP ST0, ST1     ; Сравнивает ST0 с ST1, устанавливает флаги, выталкивает ST0
```

#### FINIT/FNINIT - Инициализация FPU

##### Синтаксис
```
FINIT               ; Инициализация FPU с проверкой исключений
FNINIT              ; Инициализация FPU без проверки исключений
```

##### Описание
Инициализирует FPU, сбрасывая все регистры и флаги в начальное состояние.

### Другие операции x87 FPU

- `FSQRT` - Извлечение квадратного корня (ST0 = √ST0)
- `FABS` - Абсолютное значение (ST0 = |ST0|)
- `FCHS` - Изменение знака (ST0 = -ST0)
- `FSIN` - Синус (ST0 = sin(ST0))
- `FCOS` - Косинус (ST0 = cos(ST0))
- `FPTAN` - Частичный тангенс (ST0 = tan(ST0), затем помещает 1.0 в ST1)
- `F2XM1` - 2^x-1 (ST0 = 2^ST0-1, для -1.0 ≤ ST0 ≤ 1.0)
- `FYL2X` - y·log₂(x) (ST1 = ST1·log₂(ST0), затем выталкивает ST0)
- `FPREM` - Частичный остаток от деления (ST0 = ST0 mod ST1)
- `FRNDINT` - Округление до целого (ST0 = round(ST0))
- `FSCALE` - Масштабирование (ST0 = ST0·2^ST1)

## SSE/SSE2 инструкции для работы с плавающей точкой

SSE и SSE2 используют 16 128-битных регистров XMM0-XMM15 (в 32-битном режиме доступны только XMM0-XMM7).

### Скалярные операции (работа с одним значением)

#### MOVSS/MOVSD - Перемещение скалярного значения

##### Синтаксис
```
MOVSS xmm, xmm/m32  ; Перемещение 32-битного значения (одиночная точность)
MOVSS xmm/m32, xmm  ; Перемещение 32-битного значения (одиночная точность)
MOVSD xmm, xmm/m64  ; Перемещение 64-битного значения (двойная точность)
MOVSD xmm/m64, xmm  ; Перемещение 64-битного значения (двойная точность)
```

##### Описание
Перемещает скалярное значение с плавающей точкой между регистрами XMM или между регистром XMM и памятью.

##### Примеры
```assembly
MOVSS XMM0, [RBX]   ; Загружает 32-битное значение из памяти в XMM0
MOVSD XMM1, XMM2    ; Копирует 64-битное значение из XMM2 в XMM1
MOVSS [RAX], XMM3   ; Сохраняет 32-битное значение из XMM3 в память
```

#### ADDSS/ADDSD - Сложение скалярных значений

##### Синтаксис
```
ADDSS xmm1, xmm2/m32 ; xmm1[0:31] = xmm1[0:31] + xmm2/m32[0:31]
ADDSD xmm1, xmm2/m64 ; xmm1[0:63] = xmm1[0:63] + xmm2/m64[0:63]
```

##### Описание
Складывает скалярные значения с плавающей точкой.

##### Примеры
```assembly
ADDSS XMM0, XMM1    ; XMM0 = XMM0 + XMM1 (одиночная точность)
ADDSD XMM2, [RCX]   ; XMM2 = XMM2 + [RCX] (двойная точность)
```

#### SUBSS/SUBSD - Вычитание скалярных значений

##### Синтаксис
```
SUBSS xmm1, xmm2/m32 ; xmm1[0:31] = xmm1[0:31] - xmm2/m32[0:31]
SUBSD xmm1, xmm2/m64 ; xmm1[0:63] = xmm1[0:63] - xmm2/m64[0:63]
```

##### Описание
Вычитает скалярные значения с плавающей точкой.

##### Примеры
```assembly
SUBSS XMM0, XMM1    ; XMM0 = XMM0 - XMM1 (одиночная точность)
SUBSD XMM2, [RCX]   ; XMM2 = XMM2 - [RCX] (двойная точность)
```

#### MULSS/MULSD - Умножение скалярных значений

##### Синтаксис
```
MULSS xmm1, xmm2/m32 ; xmm1[0:31] = xmm1[0:31] * xmm2/m32[0:31]
MULSD xmm1, xmm2/m64 ; xmm1[0:63] = xmm1[0:63] * xmm2/m64[0:63]
```

##### Описание
Умножает скалярные значения с плавающей точкой.

##### Примеры
```assembly
MULSS XMM0, XMM1    ; XMM0 = XMM0 * XMM1 (одиночная точность)
MULSD XMM2, [RCX]   ; XMM2 = XMM2 * [RCX] (двойная точность)
```

#### DIVSS/DIVSD - Деление скалярных значений

##### Синтаксис
```
DIVSS xmm1, xmm2/m32 ; xmm1[0:31] = xmm1[0:31] / xmm2/m32[0:31]
DIVSD xmm1, xmm2/m64 ; xmm1[0:63] = xmm1[0:63] / xmm2/m64[0:63]
```

##### Описание
Делит скалярные значения с плавающей точкой.

##### Примеры
```assembly
DIVSS XMM0, XMM1    ; XMM0 = XMM0 / XMM1 (одиночная точность)
DIVSD XMM2, [RCX]   ; XMM2 = XMM2 / [RCX] (двойная точность)
```

#### SQRTSS/SQRTSD - Извлечение квадратного корня

##### Синтаксис
```
SQRTSS xmm1, xmm2/m32 ; xmm1[0:31] = √(xmm2/m32[0:31])
SQRTSD xmm1, xmm2/m64 ; xmm1[0:63] = √(xmm2/m64[0:63])
```

##### Описание
Вычисляет квадратный корень из скалярного значения с плавающей точкой.

##### Примеры
```assembly
SQRTSS XMM0, XMM1   ; XMM0 = √XMM1 (одиночная точность)
SQRTSD XMM2, [RCX]  ; XMM2 = √[RCX] (двойная точность)
```

#### COMISS/COMISD - Сравнение скалярных значений

##### Синтаксис
```
COMISS xmm1, xmm2/m32 ; Сравнивает xmm1[0:31] с xmm2/m32[0:31]
COMISD xmm1, xmm2/m64 ; Сравнивает xmm1[0:63] с xmm2/m64[0:63]
```

##### Описание
Сравнивает скалярные значения с плавающей точкой и устанавливает флаги EFLAGS (ZF, PF, CF).

##### Примеры
```assembly
COMISS XMM0, XMM1   ; Сравнивает XMM0 с XMM1 (одиночная точность)
COMISD XMM2, [RCX]  ; Сравнивает XMM2 с [RCX] (двойная точность)
JE equal            ; Переход, если равны (ZF=1)
```

### Упакованные операции (работа с несколькими значениями)

#### MOVAPS/MOVAPD - Перемещение выровненных упакованных значений

##### Синтаксис
```
MOVAPS xmm1, xmm2/m128 ; Перемещение 4 выровненных значений одиночной точности
MOVAPS xmm1/m128, xmm2 ; Перемещение 4 выровненных значений одиночной точности
MOVAPD xmm1, xmm2/m128 ; Перемещение 2 выровненных значений двойной точности
MOVAPD xmm1/m128, xmm2 ; Перемещение 2 выровненных значений двойной точности
```

##### Описание
Перемещает выровненные упакованные значения с плавающей точкой между регистрами XMM или между регистром XMM и памятью.

##### Примеры
```assembly
MOVAPS XMM0, [RBX]  ; Загружает 4 значения одиночной точности из памяти в XMM0
MOVAPD XMM1, XMM2   ; Копирует 2 значения двойной точности из XMM2 в XMM1
```

#### MOVUPS/MOVUPD - Перемещение невыровненных упакованных значений

##### Синтаксис
```
MOVUPS xmm1, xmm2/m128 ; Перемещение 4 невыровненных значений одиночной точности
MOVUPS xmm1/m128, xmm2 ; Перемещение 4 невыровненных значений одиночной точности
MOVUPD xmm1, xmm2/m128 ; Перемещение 2 невыровненных значений двойной точности
MOVUPD xmm1/m128, xmm2 ; Перемещение 2 невыровненных значений двойной точности
```

##### Описание
Перемещает невыровненные упакованные значения с плавающей точкой между регистрами XMM или между регистром XMM и памятью.

##### Примеры
```assembly
MOVUPS XMM0, [RBX]  ; Загружает 4 невыровненных значения одиночной точности из памяти в XMM0
MOVUPD XMM1, XMM2   ; Копирует 2 невыровненных значения двойной точности из XMM2 в XMM1
```

#### ADDPS/ADDPD - Сложение упакованных значений

##### Синтаксис
```
ADDPS xmm1, xmm2/m128 ; Сложение 4 значений одиночной точности
ADDPD xmm1, xmm2/m128 ; Сложение 2 значений двойной точности
```

##### Описание
Складывает упакованные значения с плавающей точкой.

##### Примеры
```assembly
ADDPS XMM0, XMM1    ; XMM0 = XMM0 + XMM1 (4 значения одиночной точности)
ADDPD XMM2, [RCX]   ; XMM2 = XMM2 + [RCX] (2 значения двойной точности)
```

#### SUBPS/SUBPD - Вычитание упакованных значений

##### Синтаксис
```
SUBPS xmm1, xmm2/m128 ; Вычитание 4 значений одиночной точности
SUBPD xmm1, xmm2/m128 ; Вычитание 2 значений двойной точности
```

##### Описание
Вычитает упакованные значения с плавающей точкой.

##### Примеры
```assembly
SUBPS XMM0, XMM1    ; XMM0 = XMM0 - XMM1 (4 значения одиночной точности)
SUBPD XMM2, [RCX]   ; XMM2 = XMM2 - [RCX] (2 значения двойной точности)
```

#### MULPS/MULPD - Умножение упакованных значений

##### Синтаксис
```
MULPS xmm1, xmm2/m128 ; Умножение 4 значений одиночной точности
MULPD xmm1, xmm2/m128 ; Умножение 2 значений двойной точности
```

##### Описание
Умножает упакованные значения с плавающей точкой.

##### Примеры
```assembly
MULPS XMM0, XMM1    ; XMM0 = XMM0 * XMM1 (4 значения одиночной точности)
MULPD XMM2, [RCX]   ; XMM2 = XMM2 * [RCX] (2 значения двойной точности)
```

#### DIVPS/DIVPD - Деление упакованных значений

##### Синтаксис
```
DIVPS xmm1, xmm2/m128 ; Деление 4 значений одиночной точности
DIVPD xmm1, xmm2/m128 ; Деление 2 значений двойной точности
```

##### Описание
Делит упакованные значения с плавающей точкой.

##### Примеры
```assembly
DIVPS XMM0, XMM1    ; XMM0 = XMM0 / XMM1 (4 значения одиночной точности)
DIVPD XMM2, [RCX]   ; XMM2 = XMM2 / [RCX] (2 значения двойной точности)
```

### Преобразование типов

#### CVTSS2SD/CVTSD2SS - Преобразование между одиночной и двойной точностью

##### Синтаксис
```
CVTSS2SD xmm1, xmm2/m32 ; Преобразование из одиночной в двойную точность
CVTSD2SS xmm1, xmm2/m64 ; Преобразование из двойной в одиночную точность
```

##### Описание
Преобразует значение с плавающей точкой между форматами одиночной и двойной точности.

##### Примеры
```assembly
CVTSS2SD XMM0, XMM1    ; Преобразует значение из XMM1 в формат двойной точности и сохраняет в XMM0
CVTSD2SS XMM2, [RCX]   ; Преобразует значение из памяти в формат одиночной точности и сохраняет в XMM2
```

#### CVTSI2SS/CVTSI2SD - Преобразование из целого в плавающую точку

##### Синтаксис
```
CVTSI2SS xmm, r/m32/64 ; Преобразование из целого в одиночную точность
CVTSI2SD xmm, r/m32/64 ; Преобразование из целого в двойную точность
```

##### Описание
Преобразует целое значение в значение с плавающей точкой.

##### Примеры
```assembly
CVTSI2SS XMM0, EAX     ; Преобразует 32-битное целое из EAX в формат одиночной точности
CVTSI2SD XMM1, [RBX]   ; Преобразует 32/64-битное целое из памяти в формат двойной точности
```

#### CVTTSS2SI/CVTTSD2SI - Преобразование из плавающей точки в целое с усечением

##### Синтаксис
```
CVTTSS2SI r32/64, xmm/m32 ; Преобразование из одиночной точности в целое с усечением
CVTTSD2SI r32/64, xmm/m64 ; Преобразование из двойной точности в целое с усечением
```

##### Описание
Преобразует значение с плавающей точкой в целое с усечением (отбрасыванием дробной части).

##### Примеры
```assembly
CVTTSS2SI EAX, XMM0    ; Преобразует значение из XMM0 в 32-битное целое с усечением
CVTTSD2SI RAX, [RCX]   ; Преобразует значение из памяти в 64-битное целое с усечением
```

## AVX/AVX2 инструкции для работы с плавающей точкой

AVX и AVX2 расширяют SSE инструкции, добавляя поддержку 256-битных регистров YMM0-YMM15 и трехоперандный формат (не перезаписывающий исходные операнды).

### Основные AVX инструкции

#### VMOVAPS/VMOVAPD - Перемещение выровненных упакованных значений

##### Синтаксис
```
VMOVAPS ymm1, ymm2/m256 ; Перемещение 8 выровненных значений одиночной точности
VMOVAPS ymm1/m256, ymm2 ; Перемещение 8 выровненных значений одиночной точности
VMOVAPD ymm1, ymm2/m256 ; Перемещение 4 выровненных значений двойной точности
VMOVAPD ymm1/m256, ymm2 ; Перемещение 4 выровненных значений двойной точности
```

##### Примеры
```assembly
VMOVAPS YMM0, [RBX]     ; Загружает 8 значений одиночной точности из памяти в YMM0
VMOVAPD YMM1, YMM2      ; Копирует 4 значения двойной точности из YMM2 в YMM1
```

#### VADDPS/VADDPD - Сложение упакованных значений

##### Синтаксис
```
VADDPS ymm1, ymm2, ymm3/m256 ; ymm1 = ymm2 + ymm3/m256 (8 значений одиночной точности)
VADDPD ymm1, ymm2, ymm3/m256 ; ymm1 = ymm2 + ymm3/m256 (4 значения двойной точности)
```

##### Примеры
```assembly
VADDPS YMM0, YMM1, YMM2  ; YMM0 = YMM1 + YMM2 (8 значений одиночной точности)
VADDPD YMM3, YMM4, [RCX] ; YMM3 = YMM4 + [RCX] (4 значения двойной точности)
```

#### VMULPS/VMULPD - Умножение упакованных значений

##### Синтаксис
```
VMULPS ymm1, ymm2, ymm3/m256 ; ymm1 = ymm2 * ymm3/m256 (8 значений одиночной точности)
VMULPD ymm1, ymm2, ymm3/m256 ; ymm1 = ymm2 * ymm3/m256 (4 значения двойной точности)
```

##### Примеры
```assembly
VMULPS YMM0, YMM1, YMM2  ; YMM0 = YMM1 * YMM2 (8 значений одиночной точности)
VMULPD YMM3, YMM4, [RCX] ; YMM3 = YMM4 * [RCX] (4 значения двойной точности)
```

### FMA (Fused Multiply-Add) инструкции

#### VFMADD132PS/VFMADD213PS/VFMADD231PS - Умножение-сложение с одиночной точностью

##### Синтаксис
```
VFMADD132PS ymm1, ymm2, ymm3/m256 ; ymm1 = ymm1 * ymm3/m256 + ymm2
VFMADD213PS ymm1, ymm2, ymm3/m256 ; ymm1 = ymm2 * ymm1 + ymm3/m256
VFMADD231PS ymm1, ymm2, ymm3/m256 ; ymm1 = ymm2 * ymm3/m256 + ymm1
```

##### Примеры
```assembly
VFMADD132PS YMM0, YMM1, YMM2  ; YMM0 = YMM0 * YMM2 + YMM1
VFMADD213PS YMM3, YMM4, [RCX] ; YMM3 = YMM4 * YMM3 + [RCX]
```

## Примечания

1. Выбор набора инструкций:
   - x87 FPU инструкции устарели, но все еще поддерживаются
   - SSE/SSE2 инструкции рекомендуются для большинства случаев
   - AVX/AVX2 инструкции обеспечивают лучшую производительность на современных процессорах

2. Выравнивание данных:
   - Для оптимальной производительности данные должны быть выровнены по границе 16 байт для SSE и 32 байт для AVX
   - Инструкции с префиксом "A" (MOVAPS, MOVAPD) требуют выровненных данных
   - Инструкции с префиксом "U" (MOVUPS, MOVUPD) работают с невыровненными данными, но медленнее

3. Точность вычислений:
   - x87 FPU использует 80-битный формат для внутренних вычислений
   - SSE использует 32-битный (одиночная точность) или 64-битный (двойная точность) формат
   - Результаты вычислений могут немного отличаться между разными наборами инструкций

4. Производительность:
   - Векторные инструкции (SSE, AVX) обычно эффективнее для обработки массивов данных
   - FMA инструкции могут значительно ускорить вычисления, требующие умножения и сложения
   - Переключение между разными наборами инструкций (x87 и SSE) может вызывать задержки