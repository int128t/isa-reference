# Инструкции передачи данных x86-64

Инструкции передачи данных используются для перемещения данных между регистрами, памятью и стеком. Эти инструкции являются одними из наиболее часто используемых в программах.

## MOV - Перемещение данных

### Синтаксис
```
MOV dest, src
```

### Описание
Копирует данные из источника (src) в приемник (dest).

### Варианты
- `MOV r/m, r` - Копирование из регистра в регистр/память
- `MOV r, r/m` - Копирование из регистра/памяти в регистр
- `MOV r/m, imm` - Копирование непосредственного значения в регистр/память
- `MOV r, moffs` - Копирование из памяти по смещению в регистр
- `MOV moffs, r` - Копирование из регистра в память по смещению

### Примеры
```assembly
MOV RAX, RBX        ; Копирует значение из RBX в RAX
MOV [RBX], RAX      ; Копирует значение из RAX в память по адресу в RBX
MOV RAX, 42         ; Загружает значение 42 в RAX
MOV RAX, [0x1000]   ; Загружает значение из памяти по адресу 0x1000 в RAX
MOV [0x1000], RAX   ; Сохраняет значение из RAX в память по адресу 0x1000
```

### Флаги
Не влияет на флаги.

## MOVZX/MOVSX - Перемещение с расширением

### Синтаксис
```
MOVZX dest, src  ; Расширение нулями
MOVSX dest, src  ; Расширение знаком
```

### Описание
Копирует данные из источника меньшего размера в приемник большего размера с расширением.
- `MOVZX` расширяет нулями (для беззнаковых чисел)
- `MOVSX` расширяет знаковым битом (для знаковых чисел)

### Примеры
```assembly
MOVZX RAX, BL    ; Копирует BL в RAX с расширением нулями
MOVSX RCX, DX    ; Копирует DX в RCX с расширением знаком
```

### Флаги
Не влияет на флаги.

## PUSH - Помещение в стек

### Синтаксис
```
PUSH src
```

### Описание
Уменьшает RSP на 8 (в 64-битном режиме) и сохраняет значение источника по адресу [RSP].

### Варианты
- `PUSH r/m` - Помещение в стек значения из регистра/памяти
- `PUSH imm` - Помещение в стек непосредственного значения

### Примеры
```assembly
PUSH RAX         ; Помещает значение RAX в стек
PUSH [RBX]       ; Помещает значение из памяти по адресу в RBX в стек
PUSH 42          ; Помещает значение 42 в стек
```

### Флаги
Не влияет на флаги.

## POP - Извлечение из стека

### Синтаксис
```
POP dest
```

### Описание
Копирует значение из стека по адресу [RSP] в приемник и увеличивает RSP на 8 (в 64-битном режиме).

### Варианты
- `POP r/m` - Извлечение из стека в регистр/память

### Примеры
```assembly
POP RAX          ; Извлекает значение из стека в RAX
POP [RBX]        ; Извлекает значение из стека в память по адресу в RBX
```

### Флаги
Не влияет на флаги.

## XCHG - Обмен значениями

### Синтаксис
```
XCHG op1, op2
```

### Описание
Обменивает значения между двумя операндами.

### Варианты
- `XCHG r, r/m` - Обмен между регистром и регистром/памятью

### Примеры
```assembly
XCHG RAX, RBX    ; Обменивает значения между RAX и RBX
XCHG RAX, [RCX]  ; Обменивает значение в RAX и значение в памяти по адресу в RCX
```

### Флаги
Не влияет на флаги.

### Особенности
- Операция с памятью всегда атомарна (неделима)
- Неявно использует префикс LOCK при работе с памятью

## LEA - Загрузка эффективного адреса

### Синтаксис
```
LEA dest, src
```

### Описание
Вычисляет эффективный адрес источника и загружает его в регистр-приемник. Не обращается к памяти по вычисленному адресу.

### Примеры
```assembly
LEA RAX, [RBX+RCX*4+16]  ; Загружает в RAX значение (RBX+RCX*4+16)
LEA RDX, [RIP+32]        ; Загружает в RDX адрес, относительный к RIP
```

### Флаги
Не влияет на флаги.

### Применение
- Вычисление адресов
- Быстрое умножение и сложение (например, `LEA RAX, [RAX+RAX*2]` эквивалентно `RAX = RAX*3`)

## CMOV - Условное перемещение

### Синтаксис
```
CMOVcc dest, src
```
где cc - условие (например, E, NE, G, L и т.д.)

### Описание
Копирует значение из источника в приемник только если выполняется указанное условие.

### Примеры
```assembly
CMOVE RAX, RBX   ; Копирует RBX в RAX, если ZF=1 (равно)
CMOVNE RAX, RBX  ; Копирует RBX в RAX, если ZF=0 (не равно)
CMOVG RAX, RBX   ; Копирует RBX в RAX, если ZF=0 и SF=OF (больше, для знаковых)
```

### Флаги
Не влияет на флаги.

## MOVS - Перемещение строки

### Синтаксис
```
MOVSB/MOVSW/MOVSD/MOVSQ
```

### Описание
Копирует байт/слово/двойное слово/четверное слово из памяти по адресу [RSI] в память по адресу [RDI], затем увеличивает или уменьшает RSI и RDI в зависимости от флага DF.

### Примеры
```assembly
MOVSB           ; Копирует байт из [RSI] в [RDI]
REP MOVSQ       ; Копирует RCX четверных слов из [RSI] в [RDI]
```

### Флаги
Не влияет на флаги.

## Другие инструкции передачи данных

### MOVAPS/MOVUPS - Перемещение выровненных/невыровненных упакованных значений с плавающей точкой
```assembly
MOVAPS XMM1, XMM2       ; Копирует выровненные 128 бит из XMM2 в XMM1
MOVUPS XMM1, [RAX]      ; Копирует невыровненные 128 бит из памяти в XMM1
```

### MOVD/MOVQ - Перемещение 32/64 бит между регистрами общего назначения и XMM/MMX
```assembly
MOVD XMM0, EAX          ; Копирует 32 бита из EAX в младшие биты XMM0
MOVQ RAX, XMM0          ; Копирует 64 бита из XMM0 в RAX
```

### MOVDQA/MOVDQU - Перемещение выровненных/невыровненных 128 бит
```assembly
MOVDQA XMM0, XMM1       ; Копирует выровненные 128 бит из XMM1 в XMM0
MOVDQU XMM0, [RAX]      ; Копирует невыровненные 128 бит из памяти в XMM0
```

### CMPXCHG - Сравнение и обмен
```assembly
CMPXCHG [RAX], RBX      ; Сравнивает RAX с [RAX], если равны, то [RAX] = RBX, иначе RAX = [RAX]
```

### BSWAP - Изменение порядка байтов
```assembly
BSWAP RAX               ; Меняет порядок байтов в RAX (для преобразования между little-endian и big-endian)
```

## Примечания

1. В 64-битном режиме инструкции MOV с непосредственным 64-битным значением ограничены:
   - Можно загрузить 32-битное значение с расширением знака до 64 бит
   - Для загрузки произвольного 64-битного значения нужно использовать другие методы

2. Инструкции передачи данных обычно не влияют на флаги, за исключением некоторых специальных инструкций (например, CMPXCHG).

3. При работе с памятью важно учитывать выравнивание:
   - Невыровненный доступ может быть медленнее
   - Некоторые инструкции (например, MOVAPS) требуют выравнивания

4. Для оптимизации производительности рекомендуется:
   - Минимизировать обращения к памяти
   - Использовать LEA для сложных вычислений адресов
   - Использовать CMOV вместо условных переходов, когда это возможно