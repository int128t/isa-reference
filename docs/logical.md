# Логические инструкции x86-64

Логические инструкции выполняют побитовые операции над операндами. Они широко используются для манипуляции отдельными битами, установки/сброса флагов и оптимизации кода.

## AND - Логическое И

### Синтаксис
```
AND dest, src
```

### Описание
Выполняет побитовую операцию И между источником (src) и приемником (dest), сохраняет результат в приемнике.

### Варианты
- `AND r/m, r` - Логическое И регистра с регистром/памятью
- `AND r, r/m` - Логическое И регистра/памяти с регистром
- `AND r/m, imm` - Логическое И непосредственного значения с регистром/памятью

### Примеры
```assembly
AND RAX, RBX        ; RAX = RAX & RBX
AND [RCX], RDX      ; [RCX] = [RCX] & RDX
AND RAX, 0xFF       ; RAX = RAX & 0xFF (маскирование младшего байта)
```

### Флаги
- `CF` - сбрасывается в 0
- `OF` - сбрасывается в 0
- `SF` - устанавливается, если результат отрицательный (старший бит равен 1)
- `ZF` - устанавливается, если результат равен нулю
- `PF` - устанавливается, если результат содержит четное число единичных битов
- `AF` - не определен

### Применение
- Маскирование битов (выделение определенных битов)
- Сброс определенных битов в 0
- Проверка, установлен ли определенный бит (с последующей проверкой ZF)

## OR - Логическое ИЛИ

### Синтаксис
```
OR dest, src
```

### Описание
Выполняет побитовую операцию ИЛИ между источником (src) и приемником (dest), сохраняет результат в приемнике.

### Варианты
- `OR r/m, r` - Логическое ИЛИ регистра с регистром/памятью
- `OR r, r/m` - Логическое ИЛИ регистра/памяти с регистром
- `OR r/m, imm` - Логическое ИЛИ непосредственного значения с регистром/памятью

### Примеры
```assembly
OR RAX, RBX         ; RAX = RAX | RBX
OR [RCX], RDX       ; [RCX] = [RCX] | RDX
OR RAX, 0x80        ; RAX = RAX | 0x80 (установка 7-го бита)
```

### Флаги
Влияет на флаги так же, как AND.

### Применение
- Установка определенных битов в 1
- Объединение битовых масок
- Проверка, установлен ли хотя бы один из группы битов

## XOR - Исключающее ИЛИ

### Синтаксис
```
XOR dest, src
```

### Описание
Выполняет побитовую операцию исключающее ИЛИ между источником (src) и приемником (dest), сохраняет результат в приемнике.

### Варианты
- `XOR r/m, r` - Логическое исключающее ИЛИ регистра с регистром/памятью
- `XOR r, r/m` - Логическое исключающее ИЛИ регистра/памяти с регистром
- `XOR r/m, imm` - Логическое исключающее ИЛИ непосредственного значения с регистром/памятью

### Примеры
```assembly
XOR RAX, RBX        ; RAX = RAX ^ RBX
XOR [RCX], RDX      ; [RCX] = [RCX] ^ RDX
XOR RAX, RAX        ; RAX = 0 (обнуление регистра)
XOR RAX, 0x1        ; RAX = RAX ^ 0x1 (инвертирование младшего бита)
```

### Флаги
Влияет на флаги так же, как AND.

### Применение
- Обнуление регистра (`XOR reg, reg` - более эффективно, чем `MOV reg, 0`)
- Инвертирование отдельных битов
- Простое шифрование (XOR с ключом)
- Проверка на равенство (XOR двух равных значений дает 0)

## NOT - Логическое отрицание

### Синтаксис
```
NOT dest
```

### Описание
Инвертирует все биты операнда (побитовое отрицание).

### Примеры
```assembly
NOT RAX             ; RAX = ~RAX
NOT [RBX]           ; [RBX] = ~[RBX]
```

### Флаги
Не влияет на флаги.

### Применение
- Инвертирование всех битов
- Вычисление дополнения до единицы
- Часть операции отрицания (дополнение до двух)

## TEST - Проверка битов

### Синтаксис
```
TEST op1, op2
```

### Описание
Выполняет побитовую операцию И между операндами, но не сохраняет результат. Используется для установки флагов для последующих условных инструкций.

### Примеры
```assembly
TEST RAX, RBX       ; Устанавливает флаги на основе RAX & RBX
TEST RAX, 0x80      ; Проверяет, установлен ли 7-й бит в RAX
TEST RAX, RAX       ; Проверяет, равен ли RAX нулю
```

### Флаги
Влияет на флаги так же, как AND.

### Применение
- Проверка, установлен ли определенный бит
- Проверка, равен ли регистр нулю
- Проверка знака числа (тестирование старшего бита)

## BT/BTS/BTR/BTC - Операции с отдельными битами

### Синтаксис
```
BT r/m, r/imm       ; Bit Test
BTS r/m, r/imm      ; Bit Test and Set
BTR r/m, r/imm      ; Bit Test and Reset
BTC r/m, r/imm      ; Bit Test and Complement
```

### Описание
- `BT` - копирует указанный бит в флаг CF
- `BTS` - копирует указанный бит в флаг CF и устанавливает бит в 1
- `BTR` - копирует указанный бит в флаг CF и сбрасывает бит в 0
- `BTC` - копирует указанный бит в флаг CF и инвертирует бит

### Примеры
```assembly
BT RAX, 7           ; CF = 7-й бит RAX
BTS [RBX], RCX      ; CF = бит [RBX] с номером в RCX, затем устанавливает этот бит в 1
BTR RAX, 3          ; CF = 3-й бит RAX, затем сбрасывает этот бит в 0
BTC [RBX], 5        ; CF = 5-й бит [RBX], затем инвертирует этот бит
```

### Флаги
- `CF` - устанавливается в значение тестируемого бита
- `OF`, `SF`, `ZF`, `PF`, `AF` - не определены

### Применение
- Работа с битовыми полями
- Атомарные операции с битами в памяти (с префиксом LOCK)
- Реализация битовых множеств

## BSF/BSR - Сканирование битов

### Синтаксис
```
BSF dest, src       ; Bit Scan Forward
BSR dest, src       ; Bit Scan Reverse
```

### Описание
- `BSF` - находит позицию первого установленного бита (с наименьшим индексом)
- `BSR` - находит позицию последнего установленного бита (с наибольшим индексом)

### Примеры
```assembly
BSF RAX, RBX        ; RAX = индекс первого установленного бита в RBX
BSR RCX, [RDX]      ; RCX = индекс последнего установленного бита в [RDX]
```

### Флаги
- `ZF` - устанавливается, если источник равен нулю (в этом случае приемник не определен)
- Остальные флаги не определены

### Применение
- Поиск установленных битов
- Реализация алгоритмов, работающих с разреженными данными
- Оптимизация операций с битовыми полями

## POPCNT - Подсчет установленных битов

### Синтаксис
```
POPCNT dest, src
```

### Описание
Подсчитывает количество установленных битов (единиц) в источнике и сохраняет результат в приемнике.

### Примеры
```assembly
POPCNT RAX, RBX     ; RAX = количество единичных битов в RBX
```

### Флаги
- `ZF` - устанавливается, если результат равен нулю
- `CF`, `OF` - сбрасываются в 0
- `SF`, `PF`, `AF` - не определены

### Применение
- Подсчет количества установленных битов (вес Хэмминга)
- Оптимизация алгоритмов, работающих с битовыми множествами
- Вычисление расстояния Хэмминга между двумя значениями

## LZCNT/TZCNT - Подсчет ведущих/завершающих нулей

### Синтаксис
```
LZCNT dest, src     ; Leading Zero Count
TZCNT dest, src     ; Trailing Zero Count
```

### Описание
- `LZCNT` - подсчитывает количество ведущих нулевых битов
- `TZCNT` - подсчитывает количество завершающих нулевых битов

### Примеры
```assembly
LZCNT RAX, RBX      ; RAX = количество ведущих нулей в RBX
TZCNT RCX, [RDX]    ; RCX = количество завершающих нулей в [RDX]
```

### Флаги
- `ZF` - устанавливается, если результат равен размеру операнда в битах
- `CF` - устанавливается, если источник равен нулю
- Остальные флаги не определены

### Применение
- Оптимизация операций с битовыми полями
- Реализация алгоритмов, требующих быстрого определения позиции битов
- Вычисление логарифма по основанию 2 для степеней двойки

## Логические инструкции для SIMD

### Побитовые логические операции SSE

```assembly
ANDPS xmm1, xmm2/m128   ; Побитовое И для 4 чисел с плавающей точкой
ORPS xmm1, xmm2/m128    ; Побитовое ИЛИ для 4 чисел с плавающей точкой
XORPS xmm1, xmm2/m128   ; Побитовое исключающее ИЛИ для 4 чисел с плавающей точкой
ANDNPS xmm1, xmm2/m128  ; Побитовое И-НЕ для 4 чисел с плавающей точкой

ANDPD xmm1, xmm2/m128   ; Побитовое И для 2 чисел с плавающей точкой двойной точности
ORPD xmm1, xmm2/m128    ; Побитовое ИЛИ для 2 чисел с плавающей точкой двойной точности
XORPD xmm1, xmm2/m128   ; Побитовое исключающее ИЛИ для 2 чисел с плавающей точкой двойной точности
ANDNPD xmm1, xmm2/m128  ; Побитовое И-НЕ для 2 чисел с плавающей точкой двойной точности
```

### Побитовые логические операции AVX

```assembly
VANDPS ymm1, ymm2, ymm3/m256    ; Побитовое И для 8 чисел с плавающей точкой
VORPS ymm1, ymm2, ymm3/m256     ; Побитовое ИЛИ для 8 чисел с плавающей точкой
VXORPS ymm1, ymm2, ymm3/m256    ; Побитовое исключающее ИЛИ для 8 чисел с плавающей точкой
VANDNPS ymm1, ymm2, ymm3/m256   ; Побитовое И-НЕ для 8 чисел с плавающей точкой
```

## Примечания

1. Логические инструкции часто используются для оптимизации:
   - `XOR reg, reg` быстрее и компактнее, чем `MOV reg, 0`
   - `TEST reg, reg` быстрее, чем `CMP reg, 0`
   - `AND reg, 0xFF` быстрее, чем более сложные операции для выделения младшего байта

2. Инструкции `BT`, `BTS`, `BTR`, `BTC` с префиксом `LOCK` обеспечивают атомарные операции с битами в памяти, что полезно в многопоточном программировании.

3. Инструкции `POPCNT`, `LZCNT`, `TZCNT` доступны не на всех процессорах. Перед их использованием следует проверить поддержку с помощью `CPUID`.

4. Логические инструкции для SIMD-регистров могут использоваться не только для логических операций, но и для манипуляций с битами чисел с плавающей точкой (например, для изменения знака или маскирования NaN).